#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class CrawlPriority:
  HIGHT = 1
  NORMAL = 2
  LOW = 3

  _VALUES_TO_NAMES = {
    1: "HIGHT",
    2: "NORMAL",
    3: "LOW",
  }

  _NAMES_TO_VALUES = {
    "HIGHT": 1,
    "NORMAL": 2,
    "LOW": 3,
  }

class CrawlDocType:
  REQUESTDOC = 1
  RESPONSEDOC = 2

  _VALUES_TO_NAMES = {
    1: "REQUESTDOC",
    2: "RESPONSEDOC",
  }

  _NAMES_TO_VALUES = {
    "REQUESTDOC": 1,
    "RESPONSEDOC": 2,
  }

class RequesterType:
  VIDEO_WEB_PAGE = 1
  VIDEO_WEB_HUB = 2
  WEB_PAGE = 3
  WEB_PAGE_HUB = 4
  VERTICAL_NEWS = 5
  VERTICAL_VIDEO = 6

  _VALUES_TO_NAMES = {
    1: "VIDEO_WEB_PAGE",
    2: "VIDEO_WEB_HUB",
    3: "WEB_PAGE",
    4: "WEB_PAGE_HUB",
    5: "VERTICAL_NEWS",
    6: "VERTICAL_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "VIDEO_WEB_PAGE": 1,
    "VIDEO_WEB_HUB": 2,
    "WEB_PAGE": 3,
    "WEB_PAGE_HUB": 4,
    "VERTICAL_NEWS": 5,
    "VERTICAL_VIDEO": 6,
  }

class ReturnType:
  UNKNOWN = 0
  NODNS = 1
  NOCONNECTION = 2
  FORBIDDENROBOTS = 3
  TIMEOUT = 4
  BADTYPE = 5
  TOOBIG = 6
  BADHEADER = 7
  NETWORKERROR = 8
  SITEQUEUEFULL = 9
  INVALIDURL = 10
  INVALIDREDIRECTURL = 11
  META_REDIRECT = 12
  JS_REDIRECT = 13
  IP_BLACKLISTED = 14
  BADCONTENT = 15
  URL_BLACKLISTED = 16
  STATUS100 = 100
  STATUS101 = 101
  STATUS200 = 200
  STATUS201 = 201
  STATUS202 = 202
  STATUS203 = 203
  STATUS204 = 204
  STATUS205 = 205
  STATUS206 = 206
  STATUS300 = 300
  STATUS301 = 301
  STATUS302 = 302
  STATUS303 = 303
  STATUS304 = 304
  STATUS305 = 305
  STATUS306 = 306
  STATUS307 = 307
  STATUS400 = 400
  STATUS401 = 401
  STATUS402 = 402
  STATUS403 = 403
  STATUS404 = 404
  STATUS405 = 405
  STATUS406 = 406
  STATUS407 = 407
  STATUS408 = 408
  STATUS409 = 409
  STATUS410 = 410
  STATUS411 = 411
  STATUS412 = 412
  STATUS413 = 413
  STATUS414 = 414
  STATUS415 = 415
  STATUS416 = 416
  STATUS417 = 417
  STATUS500 = 500
  STATUS501 = 501
  STATUS502 = 502
  STATUS503 = 503
  STATUS504 = 504
  STATUS505 = 505
  STATUS509 = 509
  STATUS510 = 510

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "NODNS",
    2: "NOCONNECTION",
    3: "FORBIDDENROBOTS",
    4: "TIMEOUT",
    5: "BADTYPE",
    6: "TOOBIG",
    7: "BADHEADER",
    8: "NETWORKERROR",
    9: "SITEQUEUEFULL",
    10: "INVALIDURL",
    11: "INVALIDREDIRECTURL",
    12: "META_REDIRECT",
    13: "JS_REDIRECT",
    14: "IP_BLACKLISTED",
    15: "BADCONTENT",
    16: "URL_BLACKLISTED",
    100: "STATUS100",
    101: "STATUS101",
    200: "STATUS200",
    201: "STATUS201",
    202: "STATUS202",
    203: "STATUS203",
    204: "STATUS204",
    205: "STATUS205",
    206: "STATUS206",
    300: "STATUS300",
    301: "STATUS301",
    302: "STATUS302",
    303: "STATUS303",
    304: "STATUS304",
    305: "STATUS305",
    306: "STATUS306",
    307: "STATUS307",
    400: "STATUS400",
    401: "STATUS401",
    402: "STATUS402",
    403: "STATUS403",
    404: "STATUS404",
    405: "STATUS405",
    406: "STATUS406",
    407: "STATUS407",
    408: "STATUS408",
    409: "STATUS409",
    410: "STATUS410",
    411: "STATUS411",
    412: "STATUS412",
    413: "STATUS413",
    414: "STATUS414",
    415: "STATUS415",
    416: "STATUS416",
    417: "STATUS417",
    500: "STATUS500",
    501: "STATUS501",
    502: "STATUS502",
    503: "STATUS503",
    504: "STATUS504",
    505: "STATUS505",
    509: "STATUS509",
    510: "STATUS510",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "NODNS": 1,
    "NOCONNECTION": 2,
    "FORBIDDENROBOTS": 3,
    "TIMEOUT": 4,
    "BADTYPE": 5,
    "TOOBIG": 6,
    "BADHEADER": 7,
    "NETWORKERROR": 8,
    "SITEQUEUEFULL": 9,
    "INVALIDURL": 10,
    "INVALIDREDIRECTURL": 11,
    "META_REDIRECT": 12,
    "JS_REDIRECT": 13,
    "IP_BLACKLISTED": 14,
    "BADCONTENT": 15,
    "URL_BLACKLISTED": 16,
    "STATUS100": 100,
    "STATUS101": 101,
    "STATUS200": 200,
    "STATUS201": 201,
    "STATUS202": 202,
    "STATUS203": 203,
    "STATUS204": 204,
    "STATUS205": 205,
    "STATUS206": 206,
    "STATUS300": 300,
    "STATUS301": 301,
    "STATUS302": 302,
    "STATUS303": 303,
    "STATUS304": 304,
    "STATUS305": 305,
    "STATUS306": 306,
    "STATUS307": 307,
    "STATUS400": 400,
    "STATUS401": 401,
    "STATUS402": 402,
    "STATUS403": 403,
    "STATUS404": 404,
    "STATUS405": 405,
    "STATUS406": 406,
    "STATUS407": 407,
    "STATUS408": 408,
    "STATUS409": 409,
    "STATUS410": 410,
    "STATUS411": 411,
    "STATUS412": 412,
    "STATUS413": 413,
    "STATUS414": 414,
    "STATUS415": 415,
    "STATUS416": 416,
    "STATUS417": 417,
    "STATUS500": 500,
    "STATUS501": 501,
    "STATUS502": 502,
    "STATUS503": 503,
    "STATUS504": 504,
    "STATUS505": 505,
    "STATUS509": 509,
    "STATUS510": 510,
  }


class PageRank:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PageRank')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlParams:
  """
  Attributes:
   - max_deepth_limit
   - follow_redirection
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'max_deepth_limit', None, 0, ), # 1
    (2, TType.BOOL, 'follow_redirection', None, True, ), # 2
  )

  def __init__(self, max_deepth_limit=thrift_spec[1][4], follow_redirection=thrift_spec[2][4],):
    self.max_deepth_limit = max_deepth_limit
    self.follow_redirection = follow_redirection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.max_deepth_limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.follow_redirection = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlParams')
    if self.max_deepth_limit is not None:
      oprot.writeFieldBegin('max_deepth_limit', TType.I32, 1)
      oprot.writeI32(self.max_deepth_limit)
      oprot.writeFieldEnd()
    if self.follow_redirection is not None:
      oprot.writeFieldBegin('follow_redirection', TType.BOOL, 2)
      oprot.writeBool(self.follow_redirection)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RedirectInfo:
  """
  Attributes:
   - redirect_times
   - redirect_urls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'redirect_times', None, None, ), # 1
    (2, TType.LIST, 'redirect_urls', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, redirect_times=None, redirect_urls=None,):
    self.redirect_times = redirect_times
    self.redirect_urls = redirect_urls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.redirect_times = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.redirect_urls = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.redirect_urls.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RedirectInfo')
    if self.redirect_times is not None:
      oprot.writeFieldBegin('redirect_times', TType.I32, 1)
      oprot.writeI32(self.redirect_times)
      oprot.writeFieldEnd()
    if self.redirect_urls is not None:
      oprot.writeFieldBegin('redirect_urls', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.redirect_urls))
      for iter6 in self.redirect_urls:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request:
  """
  Attributes:
   - url
   - params
   - header
   - meta
   - raw_url
   - request_time
   - request_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRUCT, 'params', (CrawlParams, CrawlParams.thrift_spec), None, ), # 2
    (3, TType.STRING, 'header', None, None, ), # 3
    (4, TType.STRING, 'meta', None, None, ), # 4
    (5, TType.STRING, 'raw_url', None, None, ), # 5
    (6, TType.I64, 'request_time', None, None, ), # 6
    (7, TType.I32, 'request_type', None,     1, ), # 7
  )

  def __init__(self, url=None, params=None, header=None, meta=None, raw_url=None, request_time=None, request_type=thrift_spec[7][4],):
    self.url = url
    self.params = params
    self.header = header
    self.meta = meta
    self.raw_url = raw_url
    self.request_time = request_time
    self.request_type = request_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.params = CrawlParams()
          self.params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.raw_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.request_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.request_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.STRUCT, 2)
      self.params.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 3)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 4)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.raw_url is not None:
      oprot.writeFieldBegin('raw_url', TType.STRING, 5)
      oprot.writeString(self.raw_url)
      oprot.writeFieldEnd()
    if self.request_time is not None:
      oprot.writeFieldBegin('request_time', TType.I64, 6)
      oprot.writeI64(self.request_time)
      oprot.writeFieldEnd()
    if self.request_type is not None:
      oprot.writeFieldBegin('request_type', TType.I32, 7)
      oprot.writeI32(self.request_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConnectionInfo:
  """
  Attributes:
   - host
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, host=None, port=None,):
    self.host = host
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConnectionInfo')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReceiverInfo:
  """
  Attributes:
   - receivers
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'receivers', (TType.STRUCT,(ConnectionInfo, ConnectionInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, receivers=None,):
    self.receivers = receivers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.receivers = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = ConnectionInfo()
            _elem12.read(iprot)
            self.receivers.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReceiverInfo')
    if self.receivers is not None:
      oprot.writeFieldBegin('receivers', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.receivers))
      for iter13 in self.receivers:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Response:
  """
  Attributes:
   - url
   - return_code
   - redirect_info
   - header
   - meta
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I32, 'return_code', None,     0, ), # 2
    (3, TType.STRUCT, 'redirect_info', (RedirectInfo, RedirectInfo.thrift_spec), None, ), # 3
    (4, TType.STRING, 'header', None, None, ), # 4
    (5, TType.STRING, 'meta', None, None, ), # 5
  )

  def __init__(self, url=None, return_code=thrift_spec[2][4], redirect_info=None, header=None, meta=None,):
    self.url = url
    self.return_code = return_code
    self.redirect_info = redirect_info
    self.header = header
    self.meta = meta

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.return_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.redirect_info = RedirectInfo()
          self.redirect_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Response')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.return_code is not None:
      oprot.writeFieldBegin('return_code', TType.I32, 2)
      oprot.writeI32(self.return_code)
      oprot.writeFieldEnd()
    if self.redirect_info is not None:
      oprot.writeFieldBegin('redirect_info', TType.STRUCT, 3)
      self.redirect_info.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 4)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 5)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Anchor:
  """
  Attributes:
   - source
   - text
   - timestamp
   - indomain
   - count
   - source_domains
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'source', None, 0, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, 0, ), # 3
    (4, TType.BOOL, 'indomain', None, None, ), # 4
    (5, TType.I32, 'count', None, None, ), # 5
    (6, TType.LIST, 'source_domains', (TType.I32,None), None, ), # 6
  )

  def __init__(self, source=thrift_spec[1][4], text=None, timestamp=thrift_spec[3][4], indomain=None, count=None, source_domains=None,):
    self.source = source
    self.text = text
    self.timestamp = timestamp
    self.indomain = indomain
    self.count = count
    self.source_domains = source_domains

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.source = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.indomain = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.source_domains = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readI32();
            self.source_domains.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Anchor')
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.I64, 1)
      oprot.writeI64(self.source)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.indomain is not None:
      oprot.writeFieldBegin('indomain', TType.BOOL, 4)
      oprot.writeBool(self.indomain)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.source_domains is not None:
      oprot.writeFieldBegin('source_domains', TType.LIST, 6)
      oprot.writeListBegin(TType.I32, len(self.source_domains))
      for iter20 in self.source_domains:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnchorList:
  """
  Attributes:
   - indomain_anchors
   - outdomain_anchors
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'indomain_anchors', (TType.STRUCT,(Anchor, Anchor.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'outdomain_anchors', (TType.STRUCT,(Anchor, Anchor.thrift_spec)), None, ), # 2
  )

  def __init__(self, indomain_anchors=None, outdomain_anchors=None,):
    self.indomain_anchors = indomain_anchors
    self.outdomain_anchors = outdomain_anchors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.indomain_anchors = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Anchor()
            _elem26.read(iprot)
            self.indomain_anchors.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outdomain_anchors = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = Anchor()
            _elem32.read(iprot)
            self.outdomain_anchors.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnchorList')
    if self.indomain_anchors is not None:
      oprot.writeFieldBegin('indomain_anchors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.indomain_anchors))
      for iter33 in self.indomain_anchors:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outdomain_anchors is not None:
      oprot.writeFieldBegin('outdomain_anchors', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.outdomain_anchors))
      for iter34 in self.outdomain_anchors:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlDocAttachment:
  """
  Attributes:
   - comment_num
   - content_body
   - read_num
   - title
   - article_time_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'comment_num', None, None, ), # 1
    (2, TType.STRING, 'content_body', None, None, ), # 2
    (3, TType.I32, 'read_num', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
    (5, TType.STRING, 'article_time_str', None, None, ), # 5
  )

  def __init__(self, comment_num=None, content_body=None, read_num=None, title=None, article_time_str=None,):
    self.comment_num = comment_num
    self.content_body = content_body
    self.read_num = read_num
    self.title = title
    self.article_time_str = article_time_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.comment_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.content_body = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.read_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.article_time_str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlDocAttachment')
    if self.comment_num is not None:
      oprot.writeFieldBegin('comment_num', TType.I32, 1)
      oprot.writeI32(self.comment_num)
      oprot.writeFieldEnd()
    if self.content_body is not None:
      oprot.writeFieldBegin('content_body', TType.STRING, 2)
      oprot.writeString(self.content_body)
      oprot.writeFieldEnd()
    if self.read_num is not None:
      oprot.writeFieldBegin('read_num', TType.I32, 3)
      oprot.writeI32(self.read_num)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.article_time_str is not None:
      oprot.writeFieldBegin('article_time_str', TType.STRING, 5)
      oprot.writeString(self.article_time_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlDoc:
  """
  Attributes:
   - docid
   - doctype
   - request
   - response
   - docencod
   - crawl_time
   - priority
   - page_timestamp
   - content
   - refer_url
   - page_rank
   - anchor_list
   - receiver_info
   - original_code
   - attachment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'docid', None, -1, ), # 1
    (2, TType.I32, 'doctype', None, None, ), # 2
    (3, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'response', (Response, Response.thrift_spec), None, ), # 4
    (5, TType.STRING, 'docencod', None, "utf8", ), # 5
    (6, TType.I64, 'crawl_time', None, None, ), # 6
    (7, TType.I32, 'priority', None,     2, ), # 7
    (8, TType.I64, 'page_timestamp', None, None, ), # 8
    (9, TType.STRING, 'content', None, None, ), # 9
    (10, TType.STRING, 'refer_url', None, None, ), # 10
    (11, TType.STRUCT, 'page_rank', (PageRank, PageRank.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'anchor_list', (AnchorList, AnchorList.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'receiver_info', (ReceiverInfo, ReceiverInfo.thrift_spec), None, ), # 13
    (14, TType.STRING, 'original_code', None, None, ), # 14
    (15, TType.STRUCT, 'attachment', (CrawlDocAttachment, CrawlDocAttachment.thrift_spec), None, ), # 15
  )

  def __init__(self, docid=thrift_spec[1][4], doctype=None, request=None, response=None, docencod=thrift_spec[5][4], crawl_time=None, priority=thrift_spec[7][4], page_timestamp=None, content=None, refer_url=None, page_rank=None, anchor_list=None, receiver_info=None, original_code=None, attachment=None,):
    self.docid = docid
    self.doctype = doctype
    self.request = request
    self.response = response
    self.docencod = docencod
    self.crawl_time = crawl_time
    self.priority = priority
    self.page_timestamp = page_timestamp
    self.content = content
    self.refer_url = refer_url
    self.page_rank = page_rank
    self.anchor_list = anchor_list
    self.receiver_info = receiver_info
    self.original_code = original_code
    self.attachment = attachment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.docid = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.doctype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.response = Response()
          self.response.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.docencod = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.page_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.content = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.refer_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.page_rank = PageRank()
          self.page_rank.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.anchor_list = AnchorList()
          self.anchor_list.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.receiver_info = ReceiverInfo()
          self.receiver_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.original_code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.attachment = CrawlDocAttachment()
          self.attachment.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlDoc')
    if self.docid is not None:
      oprot.writeFieldBegin('docid', TType.I64, 1)
      oprot.writeI64(self.docid)
      oprot.writeFieldEnd()
    if self.doctype is not None:
      oprot.writeFieldBegin('doctype', TType.I32, 2)
      oprot.writeI32(self.doctype)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    if self.response is not None:
      oprot.writeFieldBegin('response', TType.STRUCT, 4)
      self.response.write(oprot)
      oprot.writeFieldEnd()
    if self.docencod is not None:
      oprot.writeFieldBegin('docencod', TType.STRING, 5)
      oprot.writeString(self.docencod)
      oprot.writeFieldEnd()
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 6)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 7)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.page_timestamp is not None:
      oprot.writeFieldBegin('page_timestamp', TType.I64, 8)
      oprot.writeI64(self.page_timestamp)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 9)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    if self.refer_url is not None:
      oprot.writeFieldBegin('refer_url', TType.STRING, 10)
      oprot.writeString(self.refer_url)
      oprot.writeFieldEnd()
    if self.page_rank is not None:
      oprot.writeFieldBegin('page_rank', TType.STRUCT, 11)
      self.page_rank.write(oprot)
      oprot.writeFieldEnd()
    if self.anchor_list is not None:
      oprot.writeFieldBegin('anchor_list', TType.STRUCT, 12)
      self.anchor_list.write(oprot)
      oprot.writeFieldEnd()
    if self.receiver_info is not None:
      oprot.writeFieldBegin('receiver_info', TType.STRUCT, 13)
      self.receiver_info.write(oprot)
      oprot.writeFieldEnd()
    if self.original_code is not None:
      oprot.writeFieldBegin('original_code', TType.STRING, 14)
      oprot.writeString(self.original_code)
      oprot.writeFieldEnd()
    if self.attachment is not None:
      oprot.writeFieldBegin('attachment', TType.STRUCT, 15)
      self.attachment.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.docid is None:
      raise TProtocol.TProtocolException(message='Required field docid is unset!')
    if self.doctype is None:
      raise TProtocol.TProtocolException(message='Required field doctype is unset!')
    if self.docencod is None:
      raise TProtocol.TProtocolException(message='Required field docencod is unset!')
    if self.crawl_time is None:
      raise TProtocol.TProtocolException(message='Required field crawl_time is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
