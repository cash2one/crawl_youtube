#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class CrawlPriority:
  HIGHT = 1
  NORMAL = 2
  LOW = 3

  _VALUES_TO_NAMES = {
    1: "HIGHT",
    2: "NORMAL",
    3: "LOW",
  }

  _NAMES_TO_VALUES = {
    "HIGHT": 1,
    "NORMAL": 2,
    "LOW": 3,
  }

class ScheduleDocType:
  NORMAL = 0
  RECRAWL_PLAY = 1
  RECRAWL_HUB = 30

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "RECRAWL_PLAY",
    30: "RECRAWL_HUB",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "RECRAWL_PLAY": 1,
    "RECRAWL_HUB": 30,
  }

class CrawlDocState:
  NORMAL = 0
  DEAD_LINK = 1
  NO_MD5 = 2

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "DEAD_LINK",
    2: "NO_MD5",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "DEAD_LINK": 1,
    "NO_MD5": 2,
  }

class CrawlStatus:
  DISCOVERED = 0
  RECRAWLED = 1
  SCHEDULING = 2
  SCHEDULED = 4
  DOWNLOADING = 8
  DOWNLOADED = 16
  EXTRACTED = 32
  MERGED = 64

  _VALUES_TO_NAMES = {
    0: "DISCOVERED",
    1: "RECRAWLED",
    2: "SCHEDULING",
    4: "SCHEDULED",
    8: "DOWNLOADING",
    16: "DOWNLOADED",
    32: "EXTRACTED",
    64: "MERGED",
  }

  _NAMES_TO_VALUES = {
    "DISCOVERED": 0,
    "RECRAWLED": 1,
    "SCHEDULING": 2,
    "SCHEDULED": 4,
    "DOWNLOADING": 8,
    "DOWNLOADED": 16,
    "EXTRACTED": 32,
    "MERGED": 64,
  }

class CrawlDocType:
  PAGE_TIME = 10
  PAGE_HOT = 20
  PAGE_PLAY = 30
  HOME = 50
  HUB_HOME = 60
  HUB_CATEGORY = 70
  HUB_FRESH_MIN = 80
  HUB_TIME_HOME = 85
  HUB_HOT_HOME = 95
  HUB_FRESH_MAX = 100
  HUB_RELATIVES = 120
  DEFAULT_DOC = 150
  HUB_OTHER = 180
  HUB_OLD = 200
  HUB_USER_RANK = 250
  HUB_USER_VIDEOS = 260

  _VALUES_TO_NAMES = {
    10: "PAGE_TIME",
    20: "PAGE_HOT",
    30: "PAGE_PLAY",
    50: "HOME",
    60: "HUB_HOME",
    70: "HUB_CATEGORY",
    80: "HUB_FRESH_MIN",
    85: "HUB_TIME_HOME",
    95: "HUB_HOT_HOME",
    100: "HUB_FRESH_MAX",
    120: "HUB_RELATIVES",
    150: "DEFAULT_DOC",
    180: "HUB_OTHER",
    200: "HUB_OLD",
    250: "HUB_USER_RANK",
    260: "HUB_USER_VIDEOS",
  }

  _NAMES_TO_VALUES = {
    "PAGE_TIME": 10,
    "PAGE_HOT": 20,
    "PAGE_PLAY": 30,
    "HOME": 50,
    "HUB_HOME": 60,
    "HUB_CATEGORY": 70,
    "HUB_FRESH_MIN": 80,
    "HUB_TIME_HOME": 85,
    "HUB_HOT_HOME": 95,
    "HUB_FRESH_MAX": 100,
    "HUB_RELATIVES": 120,
    "DEFAULT_DOC": 150,
    "HUB_OTHER": 180,
    "HUB_OLD": 200,
    "HUB_USER_RANK": 250,
    "HUB_USER_VIDEOS": 260,
  }

class PageType:
  HUB = 0
  PLAY = 1
  HOME = 2
  CHANNEL = 3
  ORDER_TYPE = 4
  RELATED_CHANNEL = 5
  RELATED_VIDEO = 6

  _VALUES_TO_NAMES = {
    0: "HUB",
    1: "PLAY",
    2: "HOME",
    3: "CHANNEL",
    4: "ORDER_TYPE",
    5: "RELATED_CHANNEL",
    6: "RELATED_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "HUB": 0,
    "PLAY": 1,
    "HOME": 2,
    "CHANNEL": 3,
    "ORDER_TYPE": 4,
    "RELATED_CHANNEL": 5,
    "RELATED_VIDEO": 6,
  }

class SourceType:
  CUSTOM = 0
  YOUTUBE = 1
  SOCIALBLADE = 2
  RELATED_CHANNEL = 3
  RELATED_VIDEO = 4

  _VALUES_TO_NAMES = {
    0: "CUSTOM",
    1: "YOUTUBE",
    2: "SOCIALBLADE",
    3: "RELATED_CHANNEL",
    4: "RELATED_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "CUSTOM": 0,
    "YOUTUBE": 1,
    "SOCIALBLADE": 2,
    "RELATED_CHANNEL": 3,
    "RELATED_VIDEO": 4,
  }

class RequesterType:
  VIDEO_WEB_PAGE = 1
  VIDEO_WEB_HUB = 2
  WEB_PAGE = 3
  WEB_PAGE_HUB = 4
  VERTICAL_NEWS = 5
  VERTICAL_VIDEO = 6

  _VALUES_TO_NAMES = {
    1: "VIDEO_WEB_PAGE",
    2: "VIDEO_WEB_HUB",
    3: "WEB_PAGE",
    4: "WEB_PAGE_HUB",
    5: "VERTICAL_NEWS",
    6: "VERTICAL_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "VIDEO_WEB_PAGE": 1,
    "VIDEO_WEB_HUB": 2,
    "WEB_PAGE": 3,
    "WEB_PAGE_HUB": 4,
    "VERTICAL_NEWS": 5,
    "VERTICAL_VIDEO": 6,
  }

class ReturnType:
  UNKNOWN = 0
  NODNS = 1
  NOCONNECTION = 2
  FORBIDDENROBOTS = 3
  TIMEOUT = 4
  BADTYPE = 5
  TOOBIG = 6
  BADHEADER = 7
  NETWORKERROR = 8
  SITEQUEUEFULL = 9
  INVALIDURL = 10
  INVALIDREDIRECTURL = 11
  META_REDIRECT = 12
  JS_REDIRECT = 13
  IP_BLACKLISTED = 14
  BADCONTENT = 15
  URL_BLACKLISTED = 16
  STATUS100 = 100
  STATUS101 = 101
  STATUS200 = 200
  STATUS201 = 201
  STATUS202 = 202
  STATUS203 = 203
  STATUS204 = 204
  STATUS205 = 205
  STATUS206 = 206
  STATUS300 = 300
  STATUS301 = 301
  STATUS302 = 302
  STATUS303 = 303
  STATUS304 = 304
  STATUS305 = 305
  STATUS306 = 306
  STATUS307 = 307
  STATUS400 = 400
  STATUS401 = 401
  STATUS402 = 402
  STATUS403 = 403
  STATUS404 = 404
  STATUS405 = 405
  STATUS406 = 406
  STATUS407 = 407
  STATUS408 = 408
  STATUS409 = 409
  STATUS410 = 410
  STATUS411 = 411
  STATUS412 = 412
  STATUS413 = 413
  STATUS414 = 414
  STATUS415 = 415
  STATUS416 = 416
  STATUS417 = 417
  STATUS500 = 500
  STATUS501 = 501
  STATUS502 = 502
  STATUS503 = 503
  STATUS504 = 504
  STATUS505 = 505
  STATUS509 = 509
  STATUS510 = 510

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "NODNS",
    2: "NOCONNECTION",
    3: "FORBIDDENROBOTS",
    4: "TIMEOUT",
    5: "BADTYPE",
    6: "TOOBIG",
    7: "BADHEADER",
    8: "NETWORKERROR",
    9: "SITEQUEUEFULL",
    10: "INVALIDURL",
    11: "INVALIDREDIRECTURL",
    12: "META_REDIRECT",
    13: "JS_REDIRECT",
    14: "IP_BLACKLISTED",
    15: "BADCONTENT",
    16: "URL_BLACKLISTED",
    100: "STATUS100",
    101: "STATUS101",
    200: "STATUS200",
    201: "STATUS201",
    202: "STATUS202",
    203: "STATUS203",
    204: "STATUS204",
    205: "STATUS205",
    206: "STATUS206",
    300: "STATUS300",
    301: "STATUS301",
    302: "STATUS302",
    303: "STATUS303",
    304: "STATUS304",
    305: "STATUS305",
    306: "STATUS306",
    307: "STATUS307",
    400: "STATUS400",
    401: "STATUS401",
    402: "STATUS402",
    403: "STATUS403",
    404: "STATUS404",
    405: "STATUS405",
    406: "STATUS406",
    407: "STATUS407",
    408: "STATUS408",
    409: "STATUS409",
    410: "STATUS410",
    411: "STATUS411",
    412: "STATUS412",
    413: "STATUS413",
    414: "STATUS414",
    415: "STATUS415",
    416: "STATUS416",
    417: "STATUS417",
    500: "STATUS500",
    501: "STATUS501",
    502: "STATUS502",
    503: "STATUS503",
    504: "STATUS504",
    505: "STATUS505",
    509: "STATUS509",
    510: "STATUS510",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "NODNS": 1,
    "NOCONNECTION": 2,
    "FORBIDDENROBOTS": 3,
    "TIMEOUT": 4,
    "BADTYPE": 5,
    "TOOBIG": 6,
    "BADHEADER": 7,
    "NETWORKERROR": 8,
    "SITEQUEUEFULL": 9,
    "INVALIDURL": 10,
    "INVALIDREDIRECTURL": 11,
    "META_REDIRECT": 12,
    "JS_REDIRECT": 13,
    "IP_BLACKLISTED": 14,
    "BADCONTENT": 15,
    "URL_BLACKLISTED": 16,
    "STATUS100": 100,
    "STATUS101": 101,
    "STATUS200": 200,
    "STATUS201": 201,
    "STATUS202": 202,
    "STATUS203": 203,
    "STATUS204": 204,
    "STATUS205": 205,
    "STATUS206": 206,
    "STATUS300": 300,
    "STATUS301": 301,
    "STATUS302": 302,
    "STATUS303": 303,
    "STATUS304": 304,
    "STATUS305": 305,
    "STATUS306": 306,
    "STATUS307": 307,
    "STATUS400": 400,
    "STATUS401": 401,
    "STATUS402": 402,
    "STATUS403": 403,
    "STATUS404": 404,
    "STATUS405": 405,
    "STATUS406": 406,
    "STATUS407": 407,
    "STATUS408": 408,
    "STATUS409": 409,
    "STATUS410": 410,
    "STATUS411": 411,
    "STATUS412": 412,
    "STATUS413": 413,
    "STATUS414": 414,
    "STATUS415": 415,
    "STATUS416": 416,
    "STATUS417": 417,
    "STATUS500": 500,
    "STATUS501": 501,
    "STATUS502": 502,
    "STATUS503": 503,
    "STATUS504": 504,
    "STATUS505": 505,
    "STATUS509": 509,
    "STATUS510": 510,
  }

class RankingListType:
  BaiduHotRealTime = 1
  BaiduHotToday = 2
  BaiduHot7Days = 3
  BaiduHotLife = 4
  BaiduHotPlay = 5
  BaiduHotSports = 6
  BaiduHotDrama = 7
  BaiduHotMovie = 8
  BaiduHotComic = 9
  BaiduHotVariety = 10

  _VALUES_TO_NAMES = {
    1: "BaiduHotRealTime",
    2: "BaiduHotToday",
    3: "BaiduHot7Days",
    4: "BaiduHotLife",
    5: "BaiduHotPlay",
    6: "BaiduHotSports",
    7: "BaiduHotDrama",
    8: "BaiduHotMovie",
    9: "BaiduHotComic",
    10: "BaiduHotVariety",
  }

  _NAMES_TO_VALUES = {
    "BaiduHotRealTime": 1,
    "BaiduHotToday": 2,
    "BaiduHot7Days": 3,
    "BaiduHotLife": 4,
    "BaiduHotPlay": 5,
    "BaiduHotSports": 6,
    "BaiduHotDrama": 7,
    "BaiduHotMovie": 8,
    "BaiduHotComic": 9,
    "BaiduHotVariety": 10,
  }

class LanguageType:
  UNKNOWN = 0
  AF = 1
  AR = 2
  BG = 3
  BN = 4
  CA = 5
  CS = 6
  CY = 7
  DA = 8
  DE = 9
  EL = 10
  EN = 11
  ES = 12
  ET = 13
  FA = 14
  FI = 15
  FR = 16
  GU = 17
  HE = 18
  HI = 19
  HR = 20
  HU = 21
  ID = 22
  IT = 23
  JA = 24
  KN = 25
  KO = 26
  LT = 27
  LV = 28
  MK = 29
  ML = 30
  MR = 31
  NE = 32
  NL = 33
  NO = 34
  PA = 35
  PL = 36
  PT = 37
  RO = 38
  RU = 39
  SK = 40
  SL = 41
  SO = 42
  SQ = 43
  SV = 44
  SW = 45
  TA = 46
  TE = 47
  TH = 48
  TL = 49
  TR = 50
  UK = 51
  UR = 52
  VI = 53
  ZH_CN = 54
  ZH_TW = 55

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "AF",
    2: "AR",
    3: "BG",
    4: "BN",
    5: "CA",
    6: "CS",
    7: "CY",
    8: "DA",
    9: "DE",
    10: "EL",
    11: "EN",
    12: "ES",
    13: "ET",
    14: "FA",
    15: "FI",
    16: "FR",
    17: "GU",
    18: "HE",
    19: "HI",
    20: "HR",
    21: "HU",
    22: "ID",
    23: "IT",
    24: "JA",
    25: "KN",
    26: "KO",
    27: "LT",
    28: "LV",
    29: "MK",
    30: "ML",
    31: "MR",
    32: "NE",
    33: "NL",
    34: "NO",
    35: "PA",
    36: "PL",
    37: "PT",
    38: "RO",
    39: "RU",
    40: "SK",
    41: "SL",
    42: "SO",
    43: "SQ",
    44: "SV",
    45: "SW",
    46: "TA",
    47: "TE",
    48: "TH",
    49: "TL",
    50: "TR",
    51: "UK",
    52: "UR",
    53: "VI",
    54: "ZH_CN",
    55: "ZH_TW",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "AF": 1,
    "AR": 2,
    "BG": 3,
    "BN": 4,
    "CA": 5,
    "CS": 6,
    "CY": 7,
    "DA": 8,
    "DE": 9,
    "EL": 10,
    "EN": 11,
    "ES": 12,
    "ET": 13,
    "FA": 14,
    "FI": 15,
    "FR": 16,
    "GU": 17,
    "HE": 18,
    "HI": 19,
    "HR": 20,
    "HU": 21,
    "ID": 22,
    "IT": 23,
    "JA": 24,
    "KN": 25,
    "KO": 26,
    "LT": 27,
    "LV": 28,
    "MK": 29,
    "ML": 30,
    "MR": 31,
    "NE": 32,
    "NL": 33,
    "NO": 34,
    "PA": 35,
    "PL": 36,
    "PT": 37,
    "RO": 38,
    "RU": 39,
    "SK": 40,
    "SL": 41,
    "SO": 42,
    "SQ": 43,
    "SV": 44,
    "SW": 45,
    "TA": 46,
    "TE": 47,
    "TH": 48,
    "TL": 49,
    "TR": 50,
    "UK": 51,
    "UR": 52,
    "VI": 53,
    "ZH_CN": 54,
    "ZH_TW": 55,
  }


class CrawlDocAttachment:
  """
  Attributes:
   - comment_num
   - content_body
   - read_num
   - title
   - article_time_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'comment_num', None, None, ), # 1
    (2, TType.STRING, 'content_body', None, None, ), # 2
    (3, TType.I32, 'read_num', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
    (5, TType.STRING, 'article_time_str', None, None, ), # 5
  )

  def __init__(self, comment_num=None, content_body=None, read_num=None, title=None, article_time_str=None,):
    self.comment_num = comment_num
    self.content_body = content_body
    self.read_num = read_num
    self.title = title
    self.article_time_str = article_time_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.comment_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.content_body = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.read_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.article_time_str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlDocAttachment')
    if self.comment_num is not None:
      oprot.writeFieldBegin('comment_num', TType.I32, 1)
      oprot.writeI32(self.comment_num)
      oprot.writeFieldEnd()
    if self.content_body is not None:
      oprot.writeFieldBegin('content_body', TType.STRING, 2)
      oprot.writeString(self.content_body)
      oprot.writeFieldEnd()
    if self.read_num is not None:
      oprot.writeFieldBegin('read_num', TType.I32, 3)
      oprot.writeI32(self.read_num)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.article_time_str is not None:
      oprot.writeFieldBegin('article_time_str', TType.STRING, 5)
      oprot.writeString(self.article_time_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlParams:
  """
  Attributes:
   - max_deepth_limit
   - follow_redirection
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'max_deepth_limit', None, 0, ), # 1
    (2, TType.BOOL, 'follow_redirection', None, True, ), # 2
  )

  def __init__(self, max_deepth_limit=thrift_spec[1][4], follow_redirection=thrift_spec[2][4],):
    self.max_deepth_limit = max_deepth_limit
    self.follow_redirection = follow_redirection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.max_deepth_limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.follow_redirection = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlParams')
    if self.max_deepth_limit is not None:
      oprot.writeFieldBegin('max_deepth_limit', TType.I32, 1)
      oprot.writeI32(self.max_deepth_limit)
      oprot.writeFieldEnd()
    if self.follow_redirection is not None:
      oprot.writeFieldBegin('follow_redirection', TType.BOOL, 2)
      oprot.writeBool(self.follow_redirection)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RedirectInfo:
  """
  Attributes:
   - redirect_times
   - redirect_urls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'redirect_times', None, None, ), # 1
    (2, TType.LIST, 'redirect_urls', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, redirect_times=None, redirect_urls=None,):
    self.redirect_times = redirect_times
    self.redirect_urls = redirect_urls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.redirect_times = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.redirect_urls = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.redirect_urls.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RedirectInfo')
    if self.redirect_times is not None:
      oprot.writeFieldBegin('redirect_times', TType.I32, 1)
      oprot.writeI32(self.redirect_times)
      oprot.writeFieldEnd()
    if self.redirect_urls is not None:
      oprot.writeFieldBegin('redirect_urls', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.redirect_urls))
      for iter6 in self.redirect_urls:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request:
  """
  Attributes:
   - url
   - params
   - header
   - meta
   - raw_url
   - request_time
   - request_type
   - dont_filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRUCT, 'params', (CrawlParams, CrawlParams.thrift_spec), None, ), # 2
    (3, TType.STRING, 'header', None, None, ), # 3
    (4, TType.STRING, 'meta', None, None, ), # 4
    (5, TType.STRING, 'raw_url', None, None, ), # 5
    (6, TType.I64, 'request_time', None, None, ), # 6
    (7, TType.I32, 'request_type', None,     1, ), # 7
    (8, TType.BOOL, 'dont_filter', None, None, ), # 8
  )

  def __init__(self, url=None, params=None, header=None, meta=None, raw_url=None, request_time=None, request_type=thrift_spec[7][4], dont_filter=None,):
    self.url = url
    self.params = params
    self.header = header
    self.meta = meta
    self.raw_url = raw_url
    self.request_time = request_time
    self.request_type = request_type
    self.dont_filter = dont_filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.params = CrawlParams()
          self.params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.raw_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.request_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.request_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.dont_filter = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.STRUCT, 2)
      self.params.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 3)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 4)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.raw_url is not None:
      oprot.writeFieldBegin('raw_url', TType.STRING, 5)
      oprot.writeString(self.raw_url)
      oprot.writeFieldEnd()
    if self.request_time is not None:
      oprot.writeFieldBegin('request_time', TType.I64, 6)
      oprot.writeI64(self.request_time)
      oprot.writeFieldEnd()
    if self.request_type is not None:
      oprot.writeFieldBegin('request_type', TType.I32, 7)
      oprot.writeI32(self.request_type)
      oprot.writeFieldEnd()
    if self.dont_filter is not None:
      oprot.writeFieldBegin('dont_filter', TType.BOOL, 8)
      oprot.writeBool(self.dont_filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Response:
  """
  Attributes:
   - url
   - return_code
   - redirect_info
   - header
   - meta
   - body
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I32, 'return_code', None,     0, ), # 2
    (3, TType.STRUCT, 'redirect_info', (RedirectInfo, RedirectInfo.thrift_spec), None, ), # 3
    (4, TType.STRING, 'header', None, None, ), # 4
    (5, TType.STRING, 'meta', None, None, ), # 5
    (6, TType.STRING, 'body', None, None, ), # 6
  )

  def __init__(self, url=None, return_code=thrift_spec[2][4], redirect_info=None, header=None, meta=None, body=None,):
    self.url = url
    self.return_code = return_code
    self.redirect_info = redirect_info
    self.header = header
    self.meta = meta
    self.body = body

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.return_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.redirect_info = RedirectInfo()
          self.redirect_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.body = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Response')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.return_code is not None:
      oprot.writeFieldBegin('return_code', TType.I32, 2)
      oprot.writeI32(self.return_code)
      oprot.writeFieldEnd()
    if self.redirect_info is not None:
      oprot.writeFieldBegin('redirect_info', TType.STRUCT, 3)
      self.redirect_info.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 4)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 5)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRING, 6)
      oprot.writeString(self.body)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Location:
  """
  Attributes:
   - position
   - page_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'position', None, None, ), # 1
    (2, TType.I32, 'page_index', None, None, ), # 2
  )

  def __init__(self, position=None, page_index=None,):
    self.position = position
    self.page_index = page_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.page_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Location')
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 1)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.page_index is not None:
      oprot.writeFieldBegin('page_index', TType.I32, 2)
      oprot.writeI32(self.page_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Anchor:
  """
  Attributes:
   - text
   - url
   - location
   - doc_type
   - discover_time
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.STRING, 'url', None, None, ), # 2
    (3, TType.STRUCT, 'location', (Location, Location.thrift_spec), None, ), # 3
    (4, TType.I32, 'doc_type', None,     150, ), # 4
    (5, TType.I64, 'discover_time', None, None, ), # 5
  )

  def __init__(self, text=None, url=None, location=None, doc_type=thrift_spec[4][4], discover_time=None,):
    self.text = text
    self.url = url
    self.location = location
    self.doc_type = doc_type
    self.discover_time = discover_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.location = Location()
          self.location.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.discover_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Anchor')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 2)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRUCT, 3)
      self.location.write(oprot)
      oprot.writeFieldEnd()
    if self.doc_type is not None:
      oprot.writeFieldBegin('doc_type', TType.I32, 4)
      oprot.writeI32(self.doc_type)
      oprot.writeFieldEnd()
    if self.discover_time is not None:
      oprot.writeFieldBegin('discover_time', TType.I64, 5)
      oprot.writeI64(self.discover_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HistoryItem:
  """
  Attributes:
   - crawl_time
   - crawl_interval
   - play_count
   - doc_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'crawl_time', None, None, ), # 1
    (2, TType.I64, 'crawl_interval', None, None, ), # 2
    (3, TType.I64, 'play_count', None, None, ), # 3
    (4, TType.I32, 'doc_type', None, None, ), # 4
  )

  def __init__(self, crawl_time=None, crawl_interval=None, play_count=None, doc_type=None,):
    self.crawl_time = crawl_time
    self.crawl_interval = crawl_interval
    self.play_count = play_count
    self.doc_type = doc_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.crawl_interval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.play_count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HistoryItem')
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 1)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.crawl_interval is not None:
      oprot.writeFieldBegin('crawl_interval', TType.I64, 2)
      oprot.writeI64(self.crawl_interval)
      oprot.writeFieldEnd()
    if self.play_count is not None:
      oprot.writeFieldBegin('play_count', TType.I64, 3)
      oprot.writeI64(self.play_count)
      oprot.writeFieldEnd()
    if self.doc_type is not None:
      oprot.writeFieldBegin('doc_type', TType.I32, 4)
      oprot.writeI32(self.doc_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlHistory:
  """
  Attributes:
   - crawl_history
   - update_time
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'crawl_history', (TType.STRUCT,(HistoryItem, HistoryItem.thrift_spec)), None, ), # 1
    (2, TType.I64, 'update_time', None, None, ), # 2
  )

  def __init__(self, crawl_history=None, update_time=None,):
    self.crawl_history = crawl_history
    self.update_time = update_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.crawl_history = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = HistoryItem()
            _elem12.read(iprot)
            self.crawl_history.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.update_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlHistory')
    if self.crawl_history is not None:
      oprot.writeFieldBegin('crawl_history', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.crawl_history))
      for iter13 in self.crawl_history:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.update_time is not None:
      oprot.writeFieldBegin('update_time', TType.I64, 2)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScheduleInfo:
  """
  Attributes:
   - schedule_interval
   - last_schedule_time
   - next_schedule_time
   - update_time
   - crawl_doc_type
   - crawl_history
   - doc_id
   - title
   - url
   - content_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'schedule_interval', None, None, ), # 1
    (2, TType.I64, 'last_schedule_time', None, None, ), # 2
    (3, TType.I64, 'next_schedule_time', None, None, ), # 3
    (4, TType.I64, 'update_time', None, None, ), # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'crawl_doc_type', None, None, ), # 10
    (11, TType.STRUCT, 'crawl_history', (CrawlHistory, CrawlHistory.thrift_spec), None, ), # 11
    (12, TType.I64, 'doc_id', None, None, ), # 12
    (13, TType.STRING, 'title', None, None, ), # 13
    (14, TType.STRING, 'url', None, None, ), # 14
    (15, TType.I64, 'content_timestamp', None, None, ), # 15
  )

  def __init__(self, schedule_interval=None, last_schedule_time=None, next_schedule_time=None, update_time=None, crawl_doc_type=None, crawl_history=None, doc_id=None, title=None, url=None, content_timestamp=None,):
    self.schedule_interval = schedule_interval
    self.last_schedule_time = last_schedule_time
    self.next_schedule_time = next_schedule_time
    self.update_time = update_time
    self.crawl_doc_type = crawl_doc_type
    self.crawl_history = crawl_history
    self.doc_id = doc_id
    self.title = title
    self.url = url
    self.content_timestamp = content_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.schedule_interval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.last_schedule_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.next_schedule_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.update_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.crawl_doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.crawl_history = CrawlHistory()
          self.crawl_history.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.doc_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.content_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduleInfo')
    if self.schedule_interval is not None:
      oprot.writeFieldBegin('schedule_interval', TType.I64, 1)
      oprot.writeI64(self.schedule_interval)
      oprot.writeFieldEnd()
    if self.last_schedule_time is not None:
      oprot.writeFieldBegin('last_schedule_time', TType.I64, 2)
      oprot.writeI64(self.last_schedule_time)
      oprot.writeFieldEnd()
    if self.next_schedule_time is not None:
      oprot.writeFieldBegin('next_schedule_time', TType.I64, 3)
      oprot.writeI64(self.next_schedule_time)
      oprot.writeFieldEnd()
    if self.update_time is not None:
      oprot.writeFieldBegin('update_time', TType.I64, 4)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    if self.crawl_doc_type is not None:
      oprot.writeFieldBegin('crawl_doc_type', TType.I32, 10)
      oprot.writeI32(self.crawl_doc_type)
      oprot.writeFieldEnd()
    if self.crawl_history is not None:
      oprot.writeFieldBegin('crawl_history', TType.STRUCT, 11)
      self.crawl_history.write(oprot)
      oprot.writeFieldEnd()
    if self.doc_id is not None:
      oprot.writeFieldBegin('doc_id', TType.I64, 12)
      oprot.writeI64(self.doc_id)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 13)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 14)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.content_timestamp is not None:
      oprot.writeFieldBegin('content_timestamp', TType.I64, 15)
      oprot.writeI64(self.content_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingItem:
  """
  Attributes:
   - keyword
   - rank
   - search_index
   - url
   - poster
   - desc
   - content_time
   - content_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keyword', None, None, ), # 1
    (2, TType.I32, 'rank', None, None, ), # 2
    (3, TType.I64, 'search_index', None, None, ), # 3
    (4, TType.STRING, 'url', None, None, ), # 4
    (5, TType.STRING, 'poster', None, None, ), # 5
    (6, TType.STRING, 'desc', None, None, ), # 6
    (7, TType.STRING, 'content_time', None, None, ), # 7
    (8, TType.I64, 'content_timestamp', None, None, ), # 8
  )

  def __init__(self, keyword=None, rank=None, search_index=None, url=None, poster=None, desc=None, content_time=None, content_timestamp=None,):
    self.keyword = keyword
    self.rank = rank
    self.search_index = search_index
    self.url = url
    self.poster = poster
    self.desc = desc
    self.content_time = content_time
    self.content_timestamp = content_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keyword = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rank = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.search_index = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.poster = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.content_time = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.content_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingItem')
    if self.keyword is not None:
      oprot.writeFieldBegin('keyword', TType.STRING, 1)
      oprot.writeString(self.keyword)
      oprot.writeFieldEnd()
    if self.rank is not None:
      oprot.writeFieldBegin('rank', TType.I32, 2)
      oprot.writeI32(self.rank)
      oprot.writeFieldEnd()
    if self.search_index is not None:
      oprot.writeFieldBegin('search_index', TType.I64, 3)
      oprot.writeI64(self.search_index)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 4)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.poster is not None:
      oprot.writeFieldBegin('poster', TType.STRING, 5)
      oprot.writeString(self.poster)
      oprot.writeFieldEnd()
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 6)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.content_time is not None:
      oprot.writeFieldBegin('content_time', TType.STRING, 7)
      oprot.writeString(self.content_time)
      oprot.writeFieldEnd()
    if self.content_timestamp is not None:
      oprot.writeFieldBegin('content_timestamp', TType.I64, 8)
      oprot.writeI64(self.content_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingInfo:
  """
  Attributes:
   - rank_list_type
   - crawl_time
   - ranking_item
   - match_tokens
   - match_rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rank_list_type', None, None, ), # 1
    (2, TType.I64, 'crawl_time', None, None, ), # 2
    (3, TType.STRUCT, 'ranking_item', (RankingItem, RankingItem.thrift_spec), None, ), # 3
    (4, TType.LIST, 'match_tokens', (TType.STRING,None), None, ), # 4
    (5, TType.DOUBLE, 'match_rate', None, None, ), # 5
  )

  def __init__(self, rank_list_type=None, crawl_time=None, ranking_item=None, match_tokens=None, match_rate=None,):
    self.rank_list_type = rank_list_type
    self.crawl_time = crawl_time
    self.ranking_item = ranking_item
    self.match_tokens = match_tokens
    self.match_rate = match_rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rank_list_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ranking_item = RankingItem()
          self.ranking_item.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.match_tokens = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.match_tokens.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.match_rate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingInfo')
    if self.rank_list_type is not None:
      oprot.writeFieldBegin('rank_list_type', TType.I32, 1)
      oprot.writeI32(self.rank_list_type)
      oprot.writeFieldEnd()
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 2)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.ranking_item is not None:
      oprot.writeFieldBegin('ranking_item', TType.STRUCT, 3)
      self.ranking_item.write(oprot)
      oprot.writeFieldEnd()
    if self.match_tokens is not None:
      oprot.writeFieldBegin('match_tokens', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.match_tokens))
      for iter20 in self.match_tokens:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_rate is not None:
      oprot.writeFieldBegin('match_rate', TType.DOUBLE, 5)
      oprot.writeDouble(self.match_rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingList:
  """
  Attributes:
   - rank_list_type
   - ranking_items
   - crawl_time
   - url
   - ranking_list_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rank_list_type', None, None, ), # 1
    (2, TType.LIST, 'ranking_items', (TType.STRUCT,(RankingItem, RankingItem.thrift_spec)), None, ), # 2
    (3, TType.I64, 'crawl_time', None, None, ), # 3
    (4, TType.STRING, 'url', None, None, ), # 4
    (5, TType.STRING, 'ranking_list_name', None, None, ), # 5
  )

  def __init__(self, rank_list_type=None, ranking_items=None, crawl_time=None, url=None, ranking_list_name=None,):
    self.rank_list_type = rank_list_type
    self.ranking_items = ranking_items
    self.crawl_time = crawl_time
    self.url = url
    self.ranking_list_name = ranking_list_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rank_list_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ranking_items = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = RankingItem()
            _elem26.read(iprot)
            self.ranking_items.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ranking_list_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingList')
    if self.rank_list_type is not None:
      oprot.writeFieldBegin('rank_list_type', TType.I32, 1)
      oprot.writeI32(self.rank_list_type)
      oprot.writeFieldEnd()
    if self.ranking_items is not None:
      oprot.writeFieldBegin('ranking_items', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.ranking_items))
      for iter27 in self.ranking_items:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 3)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 4)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.ranking_list_name is not None:
      oprot.writeFieldBegin('ranking_list_name', TType.STRING, 5)
      oprot.writeString(self.ranking_list_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Thumbnail:
  """
  Attributes:
   - url
   - width
   - height
   - scale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I64, 'width', None, None, ), # 2
    (3, TType.I64, 'height', None, None, ), # 3
    (4, TType.STRING, 'scale', None, None, ), # 4
  )

  def __init__(self, url=None, width=None, height=None, scale=None,):
    self.url = url
    self.width = width
    self.height = height
    self.scale = scale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.width = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.height = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.scale = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Thumbnail')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I64, 2)
      oprot.writeI64(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I64, 3)
      oprot.writeI64(self.height)
      oprot.writeFieldEnd()
    if self.scale is not None:
      oprot.writeFieldBegin('scale', TType.STRING, 4)
      oprot.writeString(self.scale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.url is None:
      raise TProtocol.TProtocolException(message='Required field url is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RegionStrategy:
  """
  Attributes:
   - region_allowed
   - region_blocked
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'region_allowed', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'region_blocked', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, region_allowed=None, region_blocked=None,):
    self.region_allowed = region_allowed
    self.region_blocked = region_blocked

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.region_allowed = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString();
            self.region_allowed.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.region_blocked = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = iprot.readString();
            self.region_blocked.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RegionStrategy')
    if self.region_allowed is not None:
      oprot.writeFieldBegin('region_allowed', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.region_allowed))
      for iter40 in self.region_allowed:
        oprot.writeString(iter40)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.region_blocked is not None:
      oprot.writeFieldBegin('region_blocked', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.region_blocked))
      for iter41 in self.region_blocked:
        oprot.writeString(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
