#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Sex:
  UNKNOWN = 0
  MALE = 1
  FEMALE = 2

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "MALE",
    2: "FEMALE",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "MALE": 1,
    "FEMALE": 2,
  }

class CrawlPriority:
  HIGHT = 1
  NORMAL = 2
  LOW = 3

  _VALUES_TO_NAMES = {
    1: "HIGHT",
    2: "NORMAL",
    3: "LOW",
  }

  _NAMES_TO_VALUES = {
    "HIGHT": 1,
    "NORMAL": 2,
    "LOW": 3,
  }

class ScheduleDocType:
  NORMAL = 0
  RECRAWL_PLAY = 1
  RECRAWL_HUB = 30

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "RECRAWL_PLAY",
    30: "RECRAWL_HUB",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "RECRAWL_PLAY": 1,
    "RECRAWL_HUB": 30,
  }

class CrawlDocState:
  NORMAL = 0
  DEAD_LINK = 1
  NO_MD5 = 2

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "DEAD_LINK",
    2: "NO_MD5",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "DEAD_LINK": 1,
    "NO_MD5": 2,
  }

class UserState:
  NORMAL = 0
  DISABLE = 1

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "DISABLE",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "DISABLE": 1,
  }

class CountrySource:
  YOUTUBE = 0
  PRODUCT = 1
  POPULAR = 2
  MINED = 3

  _VALUES_TO_NAMES = {
    0: "YOUTUBE",
    1: "PRODUCT",
    2: "POPULAR",
    3: "MINED",
  }

  _NAMES_TO_VALUES = {
    "YOUTUBE": 0,
    "PRODUCT": 1,
    "POPULAR": 2,
    "MINED": 3,
  }

class CrawlStatus:
  DISCOVERED = 0
  RECRAWLED = 1
  SCHEDULING = 2
  SCHEDULED = 4
  DOWNLOADING = 8
  DOWNLOADED = 16
  EXTRACTED = 32
  MERGED = 64

  _VALUES_TO_NAMES = {
    0: "DISCOVERED",
    1: "RECRAWLED",
    2: "SCHEDULING",
    4: "SCHEDULED",
    8: "DOWNLOADING",
    16: "DOWNLOADED",
    32: "EXTRACTED",
    64: "MERGED",
  }

  _NAMES_TO_VALUES = {
    "DISCOVERED": 0,
    "RECRAWLED": 1,
    "SCHEDULING": 2,
    "SCHEDULED": 4,
    "DOWNLOADING": 8,
    "DOWNLOADED": 16,
    "EXTRACTED": 32,
    "MERGED": 64,
  }

class CrawlDocType:
  PAGE_TIME = 10
  PAGE_HOT = 20
  PAGE_PLAY = 30
  HOME = 50
  HUB_HOME = 60
  HUB_USER_RANK_HOME = 65
  HUB_CATEGORY = 70
  HUB_USER_CATEGORY = 72
  HUB_ORDER = 75
  HUB_USER_VIDEO_LIST = 77
  HUB_FRESH_MIN = 80
  HUB_TIME_HOME = 85
  HUB_HOT_HOME = 95
  HUB_FRESH_MAX = 100
  HUB_RELATIVES = 120
  DEFAULT_DOC = 150
  HUB_OTHER = 180
  HUB_OLD = 200
  HUB_USER_RANK = 250
  HUB_USER_VIDEOS = 260
  HUB_CATEGORY_COLD = 300

  _VALUES_TO_NAMES = {
    10: "PAGE_TIME",
    20: "PAGE_HOT",
    30: "PAGE_PLAY",
    50: "HOME",
    60: "HUB_HOME",
    65: "HUB_USER_RANK_HOME",
    70: "HUB_CATEGORY",
    72: "HUB_USER_CATEGORY",
    75: "HUB_ORDER",
    77: "HUB_USER_VIDEO_LIST",
    80: "HUB_FRESH_MIN",
    85: "HUB_TIME_HOME",
    95: "HUB_HOT_HOME",
    100: "HUB_FRESH_MAX",
    120: "HUB_RELATIVES",
    150: "DEFAULT_DOC",
    180: "HUB_OTHER",
    200: "HUB_OLD",
    250: "HUB_USER_RANK",
    260: "HUB_USER_VIDEOS",
    300: "HUB_CATEGORY_COLD",
  }

  _NAMES_TO_VALUES = {
    "PAGE_TIME": 10,
    "PAGE_HOT": 20,
    "PAGE_PLAY": 30,
    "HOME": 50,
    "HUB_HOME": 60,
    "HUB_USER_RANK_HOME": 65,
    "HUB_CATEGORY": 70,
    "HUB_USER_CATEGORY": 72,
    "HUB_ORDER": 75,
    "HUB_USER_VIDEO_LIST": 77,
    "HUB_FRESH_MIN": 80,
    "HUB_TIME_HOME": 85,
    "HUB_HOT_HOME": 95,
    "HUB_FRESH_MAX": 100,
    "HUB_RELATIVES": 120,
    "DEFAULT_DOC": 150,
    "HUB_OTHER": 180,
    "HUB_OLD": 200,
    "HUB_USER_RANK": 250,
    "HUB_USER_VIDEOS": 260,
    "HUB_CATEGORY_COLD": 300,
  }

class PageType:
  HUB = 0
  PLAY = 1
  HOME = 2
  CHANNEL = 3
  ORDER_TYPE = 4
  RELATED_CHANNEL = 5
  RELATED_VIDEO = 6
  CATEGORY = 7
  QUERY_SEARCH = 8

  _VALUES_TO_NAMES = {
    0: "HUB",
    1: "PLAY",
    2: "HOME",
    3: "CHANNEL",
    4: "ORDER_TYPE",
    5: "RELATED_CHANNEL",
    6: "RELATED_VIDEO",
    7: "CATEGORY",
    8: "QUERY_SEARCH",
  }

  _NAMES_TO_VALUES = {
    "HUB": 0,
    "PLAY": 1,
    "HOME": 2,
    "CHANNEL": 3,
    "ORDER_TYPE": 4,
    "RELATED_CHANNEL": 5,
    "RELATED_VIDEO": 6,
    "CATEGORY": 7,
    "QUERY_SEARCH": 8,
  }

class SourceType:
  CUSTOM = 0
  YOUTUBE = 1
  SOCIALBLADE = 2
  RELATED_CHANNEL = 3
  RELATED_VIDEO = 4

  _VALUES_TO_NAMES = {
    0: "CUSTOM",
    1: "YOUTUBE",
    2: "SOCIALBLADE",
    3: "RELATED_CHANNEL",
    4: "RELATED_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "CUSTOM": 0,
    "YOUTUBE": 1,
    "SOCIALBLADE": 2,
    "RELATED_CHANNEL": 3,
    "RELATED_VIDEO": 4,
  }

class RequesterType:
  VIDEO_WEB_PAGE = 1
  VIDEO_WEB_HUB = 2
  WEB_PAGE = 3
  WEB_PAGE_HUB = 4
  VERTICAL_NEWS = 5
  VERTICAL_VIDEO = 6

  _VALUES_TO_NAMES = {
    1: "VIDEO_WEB_PAGE",
    2: "VIDEO_WEB_HUB",
    3: "WEB_PAGE",
    4: "WEB_PAGE_HUB",
    5: "VERTICAL_NEWS",
    6: "VERTICAL_VIDEO",
  }

  _NAMES_TO_VALUES = {
    "VIDEO_WEB_PAGE": 1,
    "VIDEO_WEB_HUB": 2,
    "WEB_PAGE": 3,
    "WEB_PAGE_HUB": 4,
    "VERTICAL_NEWS": 5,
    "VERTICAL_VIDEO": 6,
  }

class ReturnType:
  UNKNOWN = 0
  NODNS = 1
  NOCONNECTION = 2
  FORBIDDENROBOTS = 3
  TIMEOUT = 4
  BADTYPE = 5
  TOOBIG = 6
  BADHEADER = 7
  NETWORKERROR = 8
  SITEQUEUEFULL = 9
  INVALIDURL = 10
  INVALIDREDIRECTURL = 11
  META_REDIRECT = 12
  JS_REDIRECT = 13
  IP_BLACKLISTED = 14
  BADCONTENT = 15
  URL_BLACKLISTED = 16
  STATUS100 = 100
  STATUS101 = 101
  STATUS200 = 200
  STATUS201 = 201
  STATUS202 = 202
  STATUS203 = 203
  STATUS204 = 204
  STATUS205 = 205
  STATUS206 = 206
  STATUS300 = 300
  STATUS301 = 301
  STATUS302 = 302
  STATUS303 = 303
  STATUS304 = 304
  STATUS305 = 305
  STATUS306 = 306
  STATUS307 = 307
  STATUS400 = 400
  STATUS401 = 401
  STATUS402 = 402
  STATUS403 = 403
  STATUS404 = 404
  STATUS405 = 405
  STATUS406 = 406
  STATUS407 = 407
  STATUS408 = 408
  STATUS409 = 409
  STATUS410 = 410
  STATUS411 = 411
  STATUS412 = 412
  STATUS413 = 413
  STATUS414 = 414
  STATUS415 = 415
  STATUS416 = 416
  STATUS417 = 417
  STATUS500 = 500
  STATUS501 = 501
  STATUS502 = 502
  STATUS503 = 503
  STATUS504 = 504
  STATUS505 = 505
  STATUS509 = 509
  STATUS510 = 510

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "NODNS",
    2: "NOCONNECTION",
    3: "FORBIDDENROBOTS",
    4: "TIMEOUT",
    5: "BADTYPE",
    6: "TOOBIG",
    7: "BADHEADER",
    8: "NETWORKERROR",
    9: "SITEQUEUEFULL",
    10: "INVALIDURL",
    11: "INVALIDREDIRECTURL",
    12: "META_REDIRECT",
    13: "JS_REDIRECT",
    14: "IP_BLACKLISTED",
    15: "BADCONTENT",
    16: "URL_BLACKLISTED",
    100: "STATUS100",
    101: "STATUS101",
    200: "STATUS200",
    201: "STATUS201",
    202: "STATUS202",
    203: "STATUS203",
    204: "STATUS204",
    205: "STATUS205",
    206: "STATUS206",
    300: "STATUS300",
    301: "STATUS301",
    302: "STATUS302",
    303: "STATUS303",
    304: "STATUS304",
    305: "STATUS305",
    306: "STATUS306",
    307: "STATUS307",
    400: "STATUS400",
    401: "STATUS401",
    402: "STATUS402",
    403: "STATUS403",
    404: "STATUS404",
    405: "STATUS405",
    406: "STATUS406",
    407: "STATUS407",
    408: "STATUS408",
    409: "STATUS409",
    410: "STATUS410",
    411: "STATUS411",
    412: "STATUS412",
    413: "STATUS413",
    414: "STATUS414",
    415: "STATUS415",
    416: "STATUS416",
    417: "STATUS417",
    500: "STATUS500",
    501: "STATUS501",
    502: "STATUS502",
    503: "STATUS503",
    504: "STATUS504",
    505: "STATUS505",
    509: "STATUS509",
    510: "STATUS510",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "NODNS": 1,
    "NOCONNECTION": 2,
    "FORBIDDENROBOTS": 3,
    "TIMEOUT": 4,
    "BADTYPE": 5,
    "TOOBIG": 6,
    "BADHEADER": 7,
    "NETWORKERROR": 8,
    "SITEQUEUEFULL": 9,
    "INVALIDURL": 10,
    "INVALIDREDIRECTURL": 11,
    "META_REDIRECT": 12,
    "JS_REDIRECT": 13,
    "IP_BLACKLISTED": 14,
    "BADCONTENT": 15,
    "URL_BLACKLISTED": 16,
    "STATUS100": 100,
    "STATUS101": 101,
    "STATUS200": 200,
    "STATUS201": 201,
    "STATUS202": 202,
    "STATUS203": 203,
    "STATUS204": 204,
    "STATUS205": 205,
    "STATUS206": 206,
    "STATUS300": 300,
    "STATUS301": 301,
    "STATUS302": 302,
    "STATUS303": 303,
    "STATUS304": 304,
    "STATUS305": 305,
    "STATUS306": 306,
    "STATUS307": 307,
    "STATUS400": 400,
    "STATUS401": 401,
    "STATUS402": 402,
    "STATUS403": 403,
    "STATUS404": 404,
    "STATUS405": 405,
    "STATUS406": 406,
    "STATUS407": 407,
    "STATUS408": 408,
    "STATUS409": 409,
    "STATUS410": 410,
    "STATUS411": 411,
    "STATUS412": 412,
    "STATUS413": 413,
    "STATUS414": 414,
    "STATUS415": 415,
    "STATUS416": 416,
    "STATUS417": 417,
    "STATUS500": 500,
    "STATUS501": 501,
    "STATUS502": 502,
    "STATUS503": 503,
    "STATUS504": 504,
    "STATUS505": 505,
    "STATUS509": 509,
    "STATUS510": 510,
  }

class RankingListType:
  BaiduHotRealTime = 1
  BaiduHotToday = 2
  BaiduHot7Days = 3
  BaiduHotLife = 4
  BaiduHotPlay = 5
  BaiduHotSports = 6
  BaiduHotDrama = 7
  BaiduHotMovie = 8
  BaiduHotComic = 9
  BaiduHotVariety = 10

  _VALUES_TO_NAMES = {
    1: "BaiduHotRealTime",
    2: "BaiduHotToday",
    3: "BaiduHot7Days",
    4: "BaiduHotLife",
    5: "BaiduHotPlay",
    6: "BaiduHotSports",
    7: "BaiduHotDrama",
    8: "BaiduHotMovie",
    9: "BaiduHotComic",
    10: "BaiduHotVariety",
  }

  _NAMES_TO_VALUES = {
    "BaiduHotRealTime": 1,
    "BaiduHotToday": 2,
    "BaiduHot7Days": 3,
    "BaiduHotLife": 4,
    "BaiduHotPlay": 5,
    "BaiduHotSports": 6,
    "BaiduHotDrama": 7,
    "BaiduHotMovie": 8,
    "BaiduHotComic": 9,
    "BaiduHotVariety": 10,
  }

class LanguageType:
  UNKNOWN = 0
  AF = 1
  AR = 2
  BG = 3
  BN = 4
  CA = 5
  CS = 6
  CY = 7
  DA = 8
  DE = 9
  EL = 10
  EN = 11
  ES = 12
  ET = 13
  FA = 14
  FI = 15
  FR = 16
  GU = 17
  HE = 18
  HI = 19
  HR = 20
  HU = 21
  ID = 22
  IT = 23
  JA = 24
  KN = 25
  KO = 26
  LT = 27
  LV = 28
  MK = 29
  ML = 30
  MR = 31
  NE = 32
  NL = 33
  NO = 34
  PA = 35
  PL = 36
  PT = 37
  RO = 38
  RU = 39
  SK = 40
  SL = 41
  SO = 42
  SQ = 43
  SV = 44
  SW = 45
  TA = 46
  TE = 47
  TH = 48
  TL = 49
  TR = 50
  UK = 51
  UR = 52
  VI = 53
  ZH_CN = 54
  ZH_TW = 55

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "AF",
    2: "AR",
    3: "BG",
    4: "BN",
    5: "CA",
    6: "CS",
    7: "CY",
    8: "DA",
    9: "DE",
    10: "EL",
    11: "EN",
    12: "ES",
    13: "ET",
    14: "FA",
    15: "FI",
    16: "FR",
    17: "GU",
    18: "HE",
    19: "HI",
    20: "HR",
    21: "HU",
    22: "ID",
    23: "IT",
    24: "JA",
    25: "KN",
    26: "KO",
    27: "LT",
    28: "LV",
    29: "MK",
    30: "ML",
    31: "MR",
    32: "NE",
    33: "NL",
    34: "NO",
    35: "PA",
    36: "PL",
    37: "PT",
    38: "RO",
    39: "RU",
    40: "SK",
    41: "SL",
    42: "SO",
    43: "SQ",
    44: "SV",
    45: "SW",
    46: "TA",
    47: "TE",
    48: "TH",
    49: "TL",
    50: "TR",
    51: "UK",
    52: "UR",
    53: "VI",
    54: "ZH_CN",
    55: "ZH_TW",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "AF": 1,
    "AR": 2,
    "BG": 3,
    "BN": 4,
    "CA": 5,
    "CS": 6,
    "CY": 7,
    "DA": 8,
    "DE": 9,
    "EL": 10,
    "EN": 11,
    "ES": 12,
    "ET": 13,
    "FA": 14,
    "FI": 15,
    "FR": 16,
    "GU": 17,
    "HE": 18,
    "HI": 19,
    "HR": 20,
    "HU": 21,
    "ID": 22,
    "IT": 23,
    "JA": 24,
    "KN": 25,
    "KO": 26,
    "LT": 27,
    "LV": 28,
    "MK": 29,
    "ML": 30,
    "MR": 31,
    "NE": 32,
    "NL": 33,
    "NO": 34,
    "PA": 35,
    "PL": 36,
    "PT": 37,
    "RO": 38,
    "RU": 39,
    "SK": 40,
    "SL": 41,
    "SO": 42,
    "SQ": 43,
    "SV": 44,
    "SW": 45,
    "TA": 46,
    "TE": 47,
    "TH": 48,
    "TL": 49,
    "TR": 50,
    "UK": 51,
    "UR": 52,
    "VI": 53,
    "ZH_CN": 54,
    "ZH_TW": 55,
  }

class CountryCode:
  UNKNOWN = 0
  AD = 1
  AE = 2
  AF = 3
  AG = 4
  AI = 5
  AL = 6
  AM = 7
  AO = 8
  AQ = 9
  AR = 10
  AS = 11
  AT = 12
  AU = 13
  AW = 14
  AX = 15
  AZ = 16
  BA = 17
  BB = 18
  BD = 19
  BE = 20
  BF = 21
  BG = 22
  BH = 23
  BI = 24
  BJ = 25
  BL = 26
  BM = 27
  BN = 28
  BO = 29
  BQ = 30
  BR = 31
  BS = 32
  BT = 33
  BV = 34
  BW = 35
  BY = 36
  BZ = 37
  CA = 38
  CC = 39
  CD = 40
  CF = 41
  CG = 42
  CH = 43
  CI = 44
  CK = 45
  CL = 46
  CM = 47
  CN = 48
  CO = 49
  CR = 50
  CU = 51
  CV = 52
  CW = 53
  CX = 54
  CY = 55
  CZ = 56
  DE = 57
  DJ = 58
  DK = 59
  DM = 60
  DO = 61
  DZ = 62
  EC = 63
  EE = 64
  EG = 65
  EH = 66
  ER = 67
  ES = 68
  ET = 69
  FI = 70
  FJ = 71
  FK = 72
  FM = 73
  FO = 74
  FR = 75
  GA = 76
  GB = 77
  GD = 78
  GE = 79
  GF = 80
  GG = 81
  GH = 82
  GI = 83
  GL = 84
  GM = 85
  GN = 86
  GP = 87
  GQ = 88
  GR = 89
  GS = 90
  GT = 91
  GU = 92
  GW = 93
  GY = 94
  HK = 95
  HM = 96
  HN = 97
  HR = 98
  HT = 99
  HU = 100
  ID = 101
  IE = 102
  IL = 103
  IM = 104
  IN = 105
  IO = 106
  IQ = 107
  IR = 108
  IS = 109
  IT = 110
  JE = 111
  JM = 112
  JO = 113
  JP = 114
  KE = 115
  KG = 116
  KH = 117
  KI = 118
  KM = 119
  KN = 120
  KP = 121
  KR = 122
  KW = 123
  KY = 124
  KZ = 125
  LA = 126
  LB = 127
  LC = 128
  LI = 129
  LK = 130
  LR = 131
  LS = 132
  LT = 133
  LU = 134
  LV = 135
  LY = 136
  MA = 137
  MC = 138
  MD = 139
  ME = 140
  MF = 141
  MG = 142
  MH = 143
  MK = 144
  ML = 145
  MM = 146
  MN = 147
  MO = 148
  MP = 149
  MQ = 150
  MR = 151
  MS = 152
  MT = 153
  MU = 154
  MV = 155
  MW = 156
  MX = 157
  MY = 158
  MZ = 159
  NA = 160
  NC = 161
  NE = 162
  NF = 163
  NG = 164
  NI = 165
  NL = 166
  NO = 167
  NP = 168
  NR = 169
  NU = 170
  NZ = 171
  OM = 172
  PA = 173
  PE = 174
  PF = 175
  PG = 176
  PH = 177
  PK = 178
  PL = 179
  PM = 180
  PN = 181
  PR = 182
  PS = 183
  PT = 184
  PW = 185
  PY = 186
  QA = 187
  RE = 188
  RO = 189
  RS = 190
  RU = 191
  RW = 192
  SA = 193
  SB = 194
  SC = 195
  SD = 196
  SE = 197
  SG = 198
  SH = 199
  SI = 200
  SJ = 201
  SK = 202
  SL = 203
  SM = 204
  SN = 205
  SO = 206
  SR = 207
  SS = 208
  ST = 209
  SV = 210
  SX = 211
  SY = 212
  SZ = 213
  TC = 214
  TD = 215
  TF = 216
  TG = 217
  TH = 218
  TJ = 219
  TK = 220
  TL = 221
  TM = 222
  TN = 223
  TO = 224
  TR = 225
  TT = 226
  TV = 227
  TW = 228
  TZ = 229
  UA = 230
  UG = 231
  UM = 232
  US = 233
  UY = 234
  UZ = 235
  VA = 236
  VC = 237
  VE = 238
  VG = 239
  VI = 240
  VN = 241
  VU = 242
  WF = 243
  WS = 244
  YE = 245
  YT = 246
  ZA = 247
  ZM = 248
  ZW = 249

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "AD",
    2: "AE",
    3: "AF",
    4: "AG",
    5: "AI",
    6: "AL",
    7: "AM",
    8: "AO",
    9: "AQ",
    10: "AR",
    11: "AS",
    12: "AT",
    13: "AU",
    14: "AW",
    15: "AX",
    16: "AZ",
    17: "BA",
    18: "BB",
    19: "BD",
    20: "BE",
    21: "BF",
    22: "BG",
    23: "BH",
    24: "BI",
    25: "BJ",
    26: "BL",
    27: "BM",
    28: "BN",
    29: "BO",
    30: "BQ",
    31: "BR",
    32: "BS",
    33: "BT",
    34: "BV",
    35: "BW",
    36: "BY",
    37: "BZ",
    38: "CA",
    39: "CC",
    40: "CD",
    41: "CF",
    42: "CG",
    43: "CH",
    44: "CI",
    45: "CK",
    46: "CL",
    47: "CM",
    48: "CN",
    49: "CO",
    50: "CR",
    51: "CU",
    52: "CV",
    53: "CW",
    54: "CX",
    55: "CY",
    56: "CZ",
    57: "DE",
    58: "DJ",
    59: "DK",
    60: "DM",
    61: "DO",
    62: "DZ",
    63: "EC",
    64: "EE",
    65: "EG",
    66: "EH",
    67: "ER",
    68: "ES",
    69: "ET",
    70: "FI",
    71: "FJ",
    72: "FK",
    73: "FM",
    74: "FO",
    75: "FR",
    76: "GA",
    77: "GB",
    78: "GD",
    79: "GE",
    80: "GF",
    81: "GG",
    82: "GH",
    83: "GI",
    84: "GL",
    85: "GM",
    86: "GN",
    87: "GP",
    88: "GQ",
    89: "GR",
    90: "GS",
    91: "GT",
    92: "GU",
    93: "GW",
    94: "GY",
    95: "HK",
    96: "HM",
    97: "HN",
    98: "HR",
    99: "HT",
    100: "HU",
    101: "ID",
    102: "IE",
    103: "IL",
    104: "IM",
    105: "IN",
    106: "IO",
    107: "IQ",
    108: "IR",
    109: "IS",
    110: "IT",
    111: "JE",
    112: "JM",
    113: "JO",
    114: "JP",
    115: "KE",
    116: "KG",
    117: "KH",
    118: "KI",
    119: "KM",
    120: "KN",
    121: "KP",
    122: "KR",
    123: "KW",
    124: "KY",
    125: "KZ",
    126: "LA",
    127: "LB",
    128: "LC",
    129: "LI",
    130: "LK",
    131: "LR",
    132: "LS",
    133: "LT",
    134: "LU",
    135: "LV",
    136: "LY",
    137: "MA",
    138: "MC",
    139: "MD",
    140: "ME",
    141: "MF",
    142: "MG",
    143: "MH",
    144: "MK",
    145: "ML",
    146: "MM",
    147: "MN",
    148: "MO",
    149: "MP",
    150: "MQ",
    151: "MR",
    152: "MS",
    153: "MT",
    154: "MU",
    155: "MV",
    156: "MW",
    157: "MX",
    158: "MY",
    159: "MZ",
    160: "NA",
    161: "NC",
    162: "NE",
    163: "NF",
    164: "NG",
    165: "NI",
    166: "NL",
    167: "NO",
    168: "NP",
    169: "NR",
    170: "NU",
    171: "NZ",
    172: "OM",
    173: "PA",
    174: "PE",
    175: "PF",
    176: "PG",
    177: "PH",
    178: "PK",
    179: "PL",
    180: "PM",
    181: "PN",
    182: "PR",
    183: "PS",
    184: "PT",
    185: "PW",
    186: "PY",
    187: "QA",
    188: "RE",
    189: "RO",
    190: "RS",
    191: "RU",
    192: "RW",
    193: "SA",
    194: "SB",
    195: "SC",
    196: "SD",
    197: "SE",
    198: "SG",
    199: "SH",
    200: "SI",
    201: "SJ",
    202: "SK",
    203: "SL",
    204: "SM",
    205: "SN",
    206: "SO",
    207: "SR",
    208: "SS",
    209: "ST",
    210: "SV",
    211: "SX",
    212: "SY",
    213: "SZ",
    214: "TC",
    215: "TD",
    216: "TF",
    217: "TG",
    218: "TH",
    219: "TJ",
    220: "TK",
    221: "TL",
    222: "TM",
    223: "TN",
    224: "TO",
    225: "TR",
    226: "TT",
    227: "TV",
    228: "TW",
    229: "TZ",
    230: "UA",
    231: "UG",
    232: "UM",
    233: "US",
    234: "UY",
    235: "UZ",
    236: "VA",
    237: "VC",
    238: "VE",
    239: "VG",
    240: "VI",
    241: "VN",
    242: "VU",
    243: "WF",
    244: "WS",
    245: "YE",
    246: "YT",
    247: "ZA",
    248: "ZM",
    249: "ZW",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "AD": 1,
    "AE": 2,
    "AF": 3,
    "AG": 4,
    "AI": 5,
    "AL": 6,
    "AM": 7,
    "AO": 8,
    "AQ": 9,
    "AR": 10,
    "AS": 11,
    "AT": 12,
    "AU": 13,
    "AW": 14,
    "AX": 15,
    "AZ": 16,
    "BA": 17,
    "BB": 18,
    "BD": 19,
    "BE": 20,
    "BF": 21,
    "BG": 22,
    "BH": 23,
    "BI": 24,
    "BJ": 25,
    "BL": 26,
    "BM": 27,
    "BN": 28,
    "BO": 29,
    "BQ": 30,
    "BR": 31,
    "BS": 32,
    "BT": 33,
    "BV": 34,
    "BW": 35,
    "BY": 36,
    "BZ": 37,
    "CA": 38,
    "CC": 39,
    "CD": 40,
    "CF": 41,
    "CG": 42,
    "CH": 43,
    "CI": 44,
    "CK": 45,
    "CL": 46,
    "CM": 47,
    "CN": 48,
    "CO": 49,
    "CR": 50,
    "CU": 51,
    "CV": 52,
    "CW": 53,
    "CX": 54,
    "CY": 55,
    "CZ": 56,
    "DE": 57,
    "DJ": 58,
    "DK": 59,
    "DM": 60,
    "DO": 61,
    "DZ": 62,
    "EC": 63,
    "EE": 64,
    "EG": 65,
    "EH": 66,
    "ER": 67,
    "ES": 68,
    "ET": 69,
    "FI": 70,
    "FJ": 71,
    "FK": 72,
    "FM": 73,
    "FO": 74,
    "FR": 75,
    "GA": 76,
    "GB": 77,
    "GD": 78,
    "GE": 79,
    "GF": 80,
    "GG": 81,
    "GH": 82,
    "GI": 83,
    "GL": 84,
    "GM": 85,
    "GN": 86,
    "GP": 87,
    "GQ": 88,
    "GR": 89,
    "GS": 90,
    "GT": 91,
    "GU": 92,
    "GW": 93,
    "GY": 94,
    "HK": 95,
    "HM": 96,
    "HN": 97,
    "HR": 98,
    "HT": 99,
    "HU": 100,
    "ID": 101,
    "IE": 102,
    "IL": 103,
    "IM": 104,
    "IN": 105,
    "IO": 106,
    "IQ": 107,
    "IR": 108,
    "IS": 109,
    "IT": 110,
    "JE": 111,
    "JM": 112,
    "JO": 113,
    "JP": 114,
    "KE": 115,
    "KG": 116,
    "KH": 117,
    "KI": 118,
    "KM": 119,
    "KN": 120,
    "KP": 121,
    "KR": 122,
    "KW": 123,
    "KY": 124,
    "KZ": 125,
    "LA": 126,
    "LB": 127,
    "LC": 128,
    "LI": 129,
    "LK": 130,
    "LR": 131,
    "LS": 132,
    "LT": 133,
    "LU": 134,
    "LV": 135,
    "LY": 136,
    "MA": 137,
    "MC": 138,
    "MD": 139,
    "ME": 140,
    "MF": 141,
    "MG": 142,
    "MH": 143,
    "MK": 144,
    "ML": 145,
    "MM": 146,
    "MN": 147,
    "MO": 148,
    "MP": 149,
    "MQ": 150,
    "MR": 151,
    "MS": 152,
    "MT": 153,
    "MU": 154,
    "MV": 155,
    "MW": 156,
    "MX": 157,
    "MY": 158,
    "MZ": 159,
    "NA": 160,
    "NC": 161,
    "NE": 162,
    "NF": 163,
    "NG": 164,
    "NI": 165,
    "NL": 166,
    "NO": 167,
    "NP": 168,
    "NR": 169,
    "NU": 170,
    "NZ": 171,
    "OM": 172,
    "PA": 173,
    "PE": 174,
    "PF": 175,
    "PG": 176,
    "PH": 177,
    "PK": 178,
    "PL": 179,
    "PM": 180,
    "PN": 181,
    "PR": 182,
    "PS": 183,
    "PT": 184,
    "PW": 185,
    "PY": 186,
    "QA": 187,
    "RE": 188,
    "RO": 189,
    "RS": 190,
    "RU": 191,
    "RW": 192,
    "SA": 193,
    "SB": 194,
    "SC": 195,
    "SD": 196,
    "SE": 197,
    "SG": 198,
    "SH": 199,
    "SI": 200,
    "SJ": 201,
    "SK": 202,
    "SL": 203,
    "SM": 204,
    "SN": 205,
    "SO": 206,
    "SR": 207,
    "SS": 208,
    "ST": 209,
    "SV": 210,
    "SX": 211,
    "SY": 212,
    "SZ": 213,
    "TC": 214,
    "TD": 215,
    "TF": 216,
    "TG": 217,
    "TH": 218,
    "TJ": 219,
    "TK": 220,
    "TL": 221,
    "TM": 222,
    "TN": 223,
    "TO": 224,
    "TR": 225,
    "TT": 226,
    "TV": 227,
    "TW": 228,
    "TZ": 229,
    "UA": 230,
    "UG": 231,
    "UM": 232,
    "US": 233,
    "UY": 234,
    "UZ": 235,
    "VA": 236,
    "VC": 237,
    "VE": 238,
    "VG": 239,
    "VI": 240,
    "VN": 241,
    "VU": 242,
    "WF": 243,
    "WS": 244,
    "YE": 245,
    "YT": 246,
    "ZA": 247,
    "ZM": 248,
    "ZW": 249,
  }


class CrawlDocAttachment:
  """
  Attributes:
   - comment_num
   - content_body
   - read_num
   - title
   - article_time_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'comment_num', None, None, ), # 1
    (2, TType.STRING, 'content_body', None, None, ), # 2
    (3, TType.I32, 'read_num', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
    (5, TType.STRING, 'article_time_str', None, None, ), # 5
  )

  def __init__(self, comment_num=None, content_body=None, read_num=None, title=None, article_time_str=None,):
    self.comment_num = comment_num
    self.content_body = content_body
    self.read_num = read_num
    self.title = title
    self.article_time_str = article_time_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.comment_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.content_body = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.read_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.article_time_str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlDocAttachment')
    if self.comment_num is not None:
      oprot.writeFieldBegin('comment_num', TType.I32, 1)
      oprot.writeI32(self.comment_num)
      oprot.writeFieldEnd()
    if self.content_body is not None:
      oprot.writeFieldBegin('content_body', TType.STRING, 2)
      oprot.writeString(self.content_body)
      oprot.writeFieldEnd()
    if self.read_num is not None:
      oprot.writeFieldBegin('read_num', TType.I32, 3)
      oprot.writeI32(self.read_num)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.article_time_str is not None:
      oprot.writeFieldBegin('article_time_str', TType.STRING, 5)
      oprot.writeString(self.article_time_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlParams:
  """
  Attributes:
   - max_deepth_limit
   - follow_redirection
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'max_deepth_limit', None, 0, ), # 1
    (2, TType.BOOL, 'follow_redirection', None, True, ), # 2
  )

  def __init__(self, max_deepth_limit=thrift_spec[1][4], follow_redirection=thrift_spec[2][4],):
    self.max_deepth_limit = max_deepth_limit
    self.follow_redirection = follow_redirection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.max_deepth_limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.follow_redirection = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlParams')
    if self.max_deepth_limit is not None:
      oprot.writeFieldBegin('max_deepth_limit', TType.I32, 1)
      oprot.writeI32(self.max_deepth_limit)
      oprot.writeFieldEnd()
    if self.follow_redirection is not None:
      oprot.writeFieldBegin('follow_redirection', TType.BOOL, 2)
      oprot.writeBool(self.follow_redirection)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RedirectInfo:
  """
  Attributes:
   - redirect_times
   - redirect_urls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'redirect_times', None, None, ), # 1
    (2, TType.LIST, 'redirect_urls', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, redirect_times=None, redirect_urls=None,):
    self.redirect_times = redirect_times
    self.redirect_urls = redirect_urls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.redirect_times = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.redirect_urls = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.redirect_urls.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RedirectInfo')
    if self.redirect_times is not None:
      oprot.writeFieldBegin('redirect_times', TType.I32, 1)
      oprot.writeI32(self.redirect_times)
      oprot.writeFieldEnd()
    if self.redirect_urls is not None:
      oprot.writeFieldBegin('redirect_urls', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.redirect_urls))
      for iter6 in self.redirect_urls:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request:
  """
  Attributes:
   - url
   - params
   - header
   - meta
   - raw_url
   - request_time
   - request_type
   - dont_filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRUCT, 'params', (CrawlParams, CrawlParams.thrift_spec), None, ), # 2
    (3, TType.STRING, 'header', None, None, ), # 3
    (4, TType.STRING, 'meta', None, None, ), # 4
    (5, TType.STRING, 'raw_url', None, None, ), # 5
    (6, TType.I64, 'request_time', None, None, ), # 6
    (7, TType.I32, 'request_type', None,     1, ), # 7
    (8, TType.BOOL, 'dont_filter', None, None, ), # 8
  )

  def __init__(self, url=None, params=None, header=None, meta=None, raw_url=None, request_time=None, request_type=thrift_spec[7][4], dont_filter=None,):
    self.url = url
    self.params = params
    self.header = header
    self.meta = meta
    self.raw_url = raw_url
    self.request_time = request_time
    self.request_type = request_type
    self.dont_filter = dont_filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.params = CrawlParams()
          self.params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.raw_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.request_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.request_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.dont_filter = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.STRUCT, 2)
      self.params.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 3)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 4)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.raw_url is not None:
      oprot.writeFieldBegin('raw_url', TType.STRING, 5)
      oprot.writeString(self.raw_url)
      oprot.writeFieldEnd()
    if self.request_time is not None:
      oprot.writeFieldBegin('request_time', TType.I64, 6)
      oprot.writeI64(self.request_time)
      oprot.writeFieldEnd()
    if self.request_type is not None:
      oprot.writeFieldBegin('request_type', TType.I32, 7)
      oprot.writeI32(self.request_type)
      oprot.writeFieldEnd()
    if self.dont_filter is not None:
      oprot.writeFieldBegin('dont_filter', TType.BOOL, 8)
      oprot.writeBool(self.dont_filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Response:
  """
  Attributes:
   - url
   - return_code
   - redirect_info
   - header
   - meta
   - body
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I32, 'return_code', None,     0, ), # 2
    (3, TType.STRUCT, 'redirect_info', (RedirectInfo, RedirectInfo.thrift_spec), None, ), # 3
    (4, TType.STRING, 'header', None, None, ), # 4
    (5, TType.STRING, 'meta', None, None, ), # 5
    (6, TType.STRING, 'body', None, None, ), # 6
  )

  def __init__(self, url=None, return_code=thrift_spec[2][4], redirect_info=None, header=None, meta=None, body=None,):
    self.url = url
    self.return_code = return_code
    self.redirect_info = redirect_info
    self.header = header
    self.meta = meta
    self.body = body

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.return_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.redirect_info = RedirectInfo()
          self.redirect_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.header = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.meta = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.body = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Response')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.return_code is not None:
      oprot.writeFieldBegin('return_code', TType.I32, 2)
      oprot.writeI32(self.return_code)
      oprot.writeFieldEnd()
    if self.redirect_info is not None:
      oprot.writeFieldBegin('redirect_info', TType.STRUCT, 3)
      self.redirect_info.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRING, 4)
      oprot.writeString(self.header)
      oprot.writeFieldEnd()
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRING, 5)
      oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRING, 6)
      oprot.writeString(self.body)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Location:
  """
  Attributes:
   - position
   - page_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'position', None, None, ), # 1
    (2, TType.I32, 'page_index', None, None, ), # 2
  )

  def __init__(self, position=None, page_index=None,):
    self.position = position
    self.page_index = page_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.page_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Location')
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 1)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.page_index is not None:
      oprot.writeFieldBegin('page_index', TType.I32, 2)
      oprot.writeI32(self.page_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Anchor:
  """
  Attributes:
   - text
   - url
   - location
   - doc_type
   - discover_time
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.STRING, 'url', None, None, ), # 2
    (3, TType.STRUCT, 'location', (Location, Location.thrift_spec), None, ), # 3
    (4, TType.I32, 'doc_type', None,     150, ), # 4
    (5, TType.I64, 'discover_time', None, None, ), # 5
  )

  def __init__(self, text=None, url=None, location=None, doc_type=thrift_spec[4][4], discover_time=None,):
    self.text = text
    self.url = url
    self.location = location
    self.doc_type = doc_type
    self.discover_time = discover_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.location = Location()
          self.location.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.discover_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Anchor')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 2)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRUCT, 3)
      self.location.write(oprot)
      oprot.writeFieldEnd()
    if self.doc_type is not None:
      oprot.writeFieldBegin('doc_type', TType.I32, 4)
      oprot.writeI32(self.doc_type)
      oprot.writeFieldEnd()
    if self.discover_time is not None:
      oprot.writeFieldBegin('discover_time', TType.I64, 5)
      oprot.writeI64(self.discover_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HistoryItem:
  """
  Attributes:
   - crawl_time
   - crawl_interval
   - play_count
   - doc_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'crawl_time', None, None, ), # 1
    (2, TType.I64, 'crawl_interval', None, None, ), # 2
    (3, TType.I64, 'play_count', None, None, ), # 3
    (4, TType.I32, 'doc_type', None, None, ), # 4
  )

  def __init__(self, crawl_time=None, crawl_interval=None, play_count=None, doc_type=None,):
    self.crawl_time = crawl_time
    self.crawl_interval = crawl_interval
    self.play_count = play_count
    self.doc_type = doc_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.crawl_interval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.play_count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HistoryItem')
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 1)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.crawl_interval is not None:
      oprot.writeFieldBegin('crawl_interval', TType.I64, 2)
      oprot.writeI64(self.crawl_interval)
      oprot.writeFieldEnd()
    if self.play_count is not None:
      oprot.writeFieldBegin('play_count', TType.I64, 3)
      oprot.writeI64(self.play_count)
      oprot.writeFieldEnd()
    if self.doc_type is not None:
      oprot.writeFieldBegin('doc_type', TType.I32, 4)
      oprot.writeI32(self.doc_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrawlHistory:
  """
  Attributes:
   - crawl_history
   - update_time
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'crawl_history', (TType.STRUCT,(HistoryItem, HistoryItem.thrift_spec)), None, ), # 1
    (2, TType.I64, 'update_time', None, None, ), # 2
  )

  def __init__(self, crawl_history=None, update_time=None,):
    self.crawl_history = crawl_history
    self.update_time = update_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.crawl_history = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = HistoryItem()
            _elem12.read(iprot)
            self.crawl_history.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.update_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrawlHistory')
    if self.crawl_history is not None:
      oprot.writeFieldBegin('crawl_history', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.crawl_history))
      for iter13 in self.crawl_history:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.update_time is not None:
      oprot.writeFieldBegin('update_time', TType.I64, 2)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScheduleInfo:
  """
  Attributes:
   - schedule_interval
   - last_schedule_time
   - next_schedule_time
   - update_time
   - crawl_doc_type
   - crawl_history
   - doc_id
   - title
   - url
   - content_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'schedule_interval', None, None, ), # 1
    (2, TType.I64, 'last_schedule_time', None, None, ), # 2
    (3, TType.I64, 'next_schedule_time', None, None, ), # 3
    (4, TType.I64, 'update_time', None, None, ), # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'crawl_doc_type', None, None, ), # 10
    (11, TType.STRUCT, 'crawl_history', (CrawlHistory, CrawlHistory.thrift_spec), None, ), # 11
    (12, TType.I64, 'doc_id', None, None, ), # 12
    (13, TType.STRING, 'title', None, None, ), # 13
    (14, TType.STRING, 'url', None, None, ), # 14
    (15, TType.I64, 'content_timestamp', None, None, ), # 15
  )

  def __init__(self, schedule_interval=None, last_schedule_time=None, next_schedule_time=None, update_time=None, crawl_doc_type=None, crawl_history=None, doc_id=None, title=None, url=None, content_timestamp=None,):
    self.schedule_interval = schedule_interval
    self.last_schedule_time = last_schedule_time
    self.next_schedule_time = next_schedule_time
    self.update_time = update_time
    self.crawl_doc_type = crawl_doc_type
    self.crawl_history = crawl_history
    self.doc_id = doc_id
    self.title = title
    self.url = url
    self.content_timestamp = content_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.schedule_interval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.last_schedule_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.next_schedule_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.update_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.crawl_doc_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.crawl_history = CrawlHistory()
          self.crawl_history.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.doc_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.content_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduleInfo')
    if self.schedule_interval is not None:
      oprot.writeFieldBegin('schedule_interval', TType.I64, 1)
      oprot.writeI64(self.schedule_interval)
      oprot.writeFieldEnd()
    if self.last_schedule_time is not None:
      oprot.writeFieldBegin('last_schedule_time', TType.I64, 2)
      oprot.writeI64(self.last_schedule_time)
      oprot.writeFieldEnd()
    if self.next_schedule_time is not None:
      oprot.writeFieldBegin('next_schedule_time', TType.I64, 3)
      oprot.writeI64(self.next_schedule_time)
      oprot.writeFieldEnd()
    if self.update_time is not None:
      oprot.writeFieldBegin('update_time', TType.I64, 4)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    if self.crawl_doc_type is not None:
      oprot.writeFieldBegin('crawl_doc_type', TType.I32, 10)
      oprot.writeI32(self.crawl_doc_type)
      oprot.writeFieldEnd()
    if self.crawl_history is not None:
      oprot.writeFieldBegin('crawl_history', TType.STRUCT, 11)
      self.crawl_history.write(oprot)
      oprot.writeFieldEnd()
    if self.doc_id is not None:
      oprot.writeFieldBegin('doc_id', TType.I64, 12)
      oprot.writeI64(self.doc_id)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 13)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 14)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.content_timestamp is not None:
      oprot.writeFieldBegin('content_timestamp', TType.I64, 15)
      oprot.writeI64(self.content_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingItem:
  """
  Attributes:
   - keyword
   - rank
   - search_index
   - url
   - poster
   - desc
   - content_time
   - content_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keyword', None, None, ), # 1
    (2, TType.I32, 'rank', None, None, ), # 2
    (3, TType.I64, 'search_index', None, None, ), # 3
    (4, TType.STRING, 'url', None, None, ), # 4
    (5, TType.STRING, 'poster', None, None, ), # 5
    (6, TType.STRING, 'desc', None, None, ), # 6
    (7, TType.STRING, 'content_time', None, None, ), # 7
    (8, TType.I64, 'content_timestamp', None, None, ), # 8
  )

  def __init__(self, keyword=None, rank=None, search_index=None, url=None, poster=None, desc=None, content_time=None, content_timestamp=None,):
    self.keyword = keyword
    self.rank = rank
    self.search_index = search_index
    self.url = url
    self.poster = poster
    self.desc = desc
    self.content_time = content_time
    self.content_timestamp = content_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keyword = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rank = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.search_index = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.poster = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.content_time = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.content_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingItem')
    if self.keyword is not None:
      oprot.writeFieldBegin('keyword', TType.STRING, 1)
      oprot.writeString(self.keyword)
      oprot.writeFieldEnd()
    if self.rank is not None:
      oprot.writeFieldBegin('rank', TType.I32, 2)
      oprot.writeI32(self.rank)
      oprot.writeFieldEnd()
    if self.search_index is not None:
      oprot.writeFieldBegin('search_index', TType.I64, 3)
      oprot.writeI64(self.search_index)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 4)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.poster is not None:
      oprot.writeFieldBegin('poster', TType.STRING, 5)
      oprot.writeString(self.poster)
      oprot.writeFieldEnd()
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 6)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.content_time is not None:
      oprot.writeFieldBegin('content_time', TType.STRING, 7)
      oprot.writeString(self.content_time)
      oprot.writeFieldEnd()
    if self.content_timestamp is not None:
      oprot.writeFieldBegin('content_timestamp', TType.I64, 8)
      oprot.writeI64(self.content_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingInfo:
  """
  Attributes:
   - rank_list_type
   - crawl_time
   - ranking_item
   - match_tokens
   - match_rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rank_list_type', None, None, ), # 1
    (2, TType.I64, 'crawl_time', None, None, ), # 2
    (3, TType.STRUCT, 'ranking_item', (RankingItem, RankingItem.thrift_spec), None, ), # 3
    (4, TType.LIST, 'match_tokens', (TType.STRING,None), None, ), # 4
    (5, TType.DOUBLE, 'match_rate', None, None, ), # 5
  )

  def __init__(self, rank_list_type=None, crawl_time=None, ranking_item=None, match_tokens=None, match_rate=None,):
    self.rank_list_type = rank_list_type
    self.crawl_time = crawl_time
    self.ranking_item = ranking_item
    self.match_tokens = match_tokens
    self.match_rate = match_rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rank_list_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ranking_item = RankingItem()
          self.ranking_item.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.match_tokens = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.match_tokens.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.match_rate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingInfo')
    if self.rank_list_type is not None:
      oprot.writeFieldBegin('rank_list_type', TType.I32, 1)
      oprot.writeI32(self.rank_list_type)
      oprot.writeFieldEnd()
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 2)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.ranking_item is not None:
      oprot.writeFieldBegin('ranking_item', TType.STRUCT, 3)
      self.ranking_item.write(oprot)
      oprot.writeFieldEnd()
    if self.match_tokens is not None:
      oprot.writeFieldBegin('match_tokens', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.match_tokens))
      for iter20 in self.match_tokens:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_rate is not None:
      oprot.writeFieldBegin('match_rate', TType.DOUBLE, 5)
      oprot.writeDouble(self.match_rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RankingList:
  """
  Attributes:
   - rank_list_type
   - ranking_items
   - crawl_time
   - url
   - ranking_list_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rank_list_type', None, None, ), # 1
    (2, TType.LIST, 'ranking_items', (TType.STRUCT,(RankingItem, RankingItem.thrift_spec)), None, ), # 2
    (3, TType.I64, 'crawl_time', None, None, ), # 3
    (4, TType.STRING, 'url', None, None, ), # 4
    (5, TType.STRING, 'ranking_list_name', None, None, ), # 5
  )

  def __init__(self, rank_list_type=None, ranking_items=None, crawl_time=None, url=None, ranking_list_name=None,):
    self.rank_list_type = rank_list_type
    self.ranking_items = ranking_items
    self.crawl_time = crawl_time
    self.url = url
    self.ranking_list_name = ranking_list_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rank_list_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ranking_items = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = RankingItem()
            _elem26.read(iprot)
            self.ranking_items.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.crawl_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ranking_list_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RankingList')
    if self.rank_list_type is not None:
      oprot.writeFieldBegin('rank_list_type', TType.I32, 1)
      oprot.writeI32(self.rank_list_type)
      oprot.writeFieldEnd()
    if self.ranking_items is not None:
      oprot.writeFieldBegin('ranking_items', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.ranking_items))
      for iter27 in self.ranking_items:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.crawl_time is not None:
      oprot.writeFieldBegin('crawl_time', TType.I64, 3)
      oprot.writeI64(self.crawl_time)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 4)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.ranking_list_name is not None:
      oprot.writeFieldBegin('ranking_list_name', TType.STRING, 5)
      oprot.writeString(self.ranking_list_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Thumbnail:
  """
  Attributes:
   - url
   - width
   - height
   - scale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I64, 'width', None, None, ), # 2
    (3, TType.I64, 'height', None, None, ), # 3
    (4, TType.STRING, 'scale', None, None, ), # 4
  )

  def __init__(self, url=None, width=None, height=None, scale=None,):
    self.url = url
    self.width = width
    self.height = height
    self.scale = scale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.width = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.height = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.scale = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Thumbnail')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I64, 2)
      oprot.writeI64(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I64, 3)
      oprot.writeI64(self.height)
      oprot.writeFieldEnd()
    if self.scale is not None:
      oprot.writeFieldBegin('scale', TType.STRING, 4)
      oprot.writeString(self.scale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.url is None:
      raise TProtocol.TProtocolException(message='Required field url is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RegionStrategy:
  """
  Attributes:
   - region_allowed
   - region_blocked
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'region_allowed', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'region_blocked', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, region_allowed=None, region_blocked=None,):
    self.region_allowed = region_allowed
    self.region_blocked = region_blocked

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.region_allowed = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString();
            self.region_allowed.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.region_blocked = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = iprot.readString();
            self.region_blocked.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RegionStrategy')
    if self.region_allowed is not None:
      oprot.writeFieldBegin('region_allowed', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.region_allowed))
      for iter40 in self.region_allowed:
        oprot.writeString(iter40)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.region_blocked is not None:
      oprot.writeFieldBegin('region_blocked', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.region_blocked))
      for iter41 in self.region_blocked:
        oprot.writeString(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CategoryProportion:
  """
  Attributes:
   - category
   - proportion
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'category', None, None, ), # 1
    (2, TType.DOUBLE, 'proportion', None, None, ), # 2
  )

  def __init__(self, category=None, proportion=None,):
    self.category = category
    self.proportion = proportion

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.category = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.proportion = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CategoryProportion')
    if self.category is not None:
      oprot.writeFieldBegin('category', TType.STRING, 1)
      oprot.writeString(self.category)
      oprot.writeFieldEnd()
    if self.proportion is not None:
      oprot.writeFieldBegin('proportion', TType.DOUBLE, 2)
      oprot.writeDouble(self.proportion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LanguageProportion:
  """
  Attributes:
   - language_type
   - proportion
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'language_type', None, None, ), # 1
    (2, TType.DOUBLE, 'proportion', None, None, ), # 2
  )

  def __init__(self, language_type=None, proportion=None,):
    self.language_type = language_type
    self.proportion = proportion

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.language_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.proportion = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LanguageProportion')
    if self.language_type is not None:
      oprot.writeFieldBegin('language_type', TType.I32, 1)
      oprot.writeI32(self.language_type)
      oprot.writeFieldEnd()
    if self.proportion is not None:
      oprot.writeFieldBegin('proportion', TType.DOUBLE, 2)
      oprot.writeDouble(self.proportion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CountryInfo:
  """
  Attributes:
   - country
   - source_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'country', None, None, ), # 1
    (2, TType.LIST, 'source_list', (TType.I32,None), None, ), # 2
  )

  def __init__(self, country=None, source_list=None,):
    self.country = country
    self.source_list = source_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.country = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.source_list = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI32();
            self.source_list.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CountryInfo')
    if self.country is not None:
      oprot.writeFieldBegin('country', TType.STRING, 1)
      oprot.writeString(self.country)
      oprot.writeFieldEnd()
    if self.source_list is not None:
      oprot.writeFieldBegin('source_list', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.source_list))
      for iter48 in self.source_list:
        oprot.writeI32(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CountrySourceInfo:
  """
  Attributes:
   - country_code
   - source_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'country_code', None, None, ), # 1
    (2, TType.LIST, 'source_list', (TType.I32,None), None, ), # 2
  )

  def __init__(self, country_code=None, source_list=None,):
    self.country_code = country_code
    self.source_list = source_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.country_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.source_list = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readI32();
            self.source_list.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CountrySourceInfo')
    if self.country_code is not None:
      oprot.writeFieldBegin('country_code', TType.I32, 1)
      oprot.writeI32(self.country_code)
      oprot.writeFieldEnd()
    if self.source_list is not None:
      oprot.writeFieldBegin('source_list', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.source_list))
      for iter55 in self.source_list:
        oprot.writeI32(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
